var $=Object.defineProperty;var B=n=>{throw TypeError(n)};var F=(n,e,t)=>e in n?$(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var S=(n,e,t)=>F(n,typeof e!="symbol"?e+"":e,t),b=(n,e,t)=>e.has(n)||B("Cannot "+t);var r=(n,e,t)=>(b(n,e,"read from private field"),t?t.call(n):e.get(n)),p=(n,e,t)=>e.has(n)?B("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),m=(n,e,t,i)=>(b(n,e,"write to private field"),i?i.call(n,t):e.set(n,t),t),D=(n,e,t)=>(b(n,e,"access private method"),t);import{S as C,s as O,p as G,u as Y,g as h,a as u}from"./vendor.B7h_mkEd.js";import{b as v}from"./appwrite.5W8SCupm.js";var _,P,J;class k{constructor(){p(this,_);S(this,"dbName","recipe-data-cache");S(this,"db",null);S(this,"version",1);S(this,"INGREDIENTS_STORE","ingredients");S(this,"RECIPE_INFO_STORE","recipe-info");S(this,"METADATA_STORE","metadata");S(this,"LAST_SYNC_KEY","lastSync");S(this,"DATA_JSON_HASH_KEY","dataJsonHash");S(this,"INGREDIENTS_COUNT_KEY","ingredientsCount");S(this,"RECIPE_INFO_KEY","data")}async open(){if(this.db)return;const e=()=>new Promise((o,d)=>{const E=indexedDB.open(this.dbName,this.version);E.onerror=()=>d(E.error),E.onsuccess=()=>o(E.result),E.onupgradeneeded=H=>{const N=H.target.result;N.objectStoreNames.contains(this.INGREDIENTS_STORE)||(N.createObjectStore(this.INGREDIENTS_STORE,{keyPath:"u"}),console.log("[RecipeDataIDBCache] Store 'ingredients' créé")),N.objectStoreNames.contains(this.RECIPE_INFO_STORE)||(N.createObjectStore(this.RECIPE_INFO_STORE),console.log("[RecipeDataIDBCache] Store 'recipe-info' créé")),N.objectStoreNames.contains(this.METADATA_STORE)||(N.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[RecipeDataIDBCache] Store 'metadata' créé"))}});let t=await e();const i=t.objectStoreNames.contains(this.INGREDIENTS_STORE),a=t.objectStoreNames.contains(this.RECIPE_INFO_STORE),s=t.objectStoreNames.contains(this.METADATA_STORE);(!i||!a||!s)&&(console.warn(`[RecipeDataIDBCache] Base corrompue détectée (ingredients=${i}, recipe-info=${a}, metadata=${s}), suppression et recréation...`),t.close(),await new Promise((o,d)=>{const E=indexedDB.deleteDatabase(this.dbName);E.onsuccess=()=>o(),E.onerror=()=>d(E.error),E.onblocked=()=>{console.warn("[RecipeDataIDBCache] Suppression bloquée, réessai...")}}),t=await e()),this.db=t,console.log(`[RecipeDataIDBCache] Base ouverte: ${this.dbName}`)}async loadAll(){if(!this.db)throw new Error("DB non ouverte");const[e,t]=await Promise.all([D(this,_,P).call(this),D(this,_,J).call(this)]);return{ingredients:e,recipeInfo:t}}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();s.onsuccess=()=>{const o={lastSync:null,dataJsonHash:null,ingredientsCount:0};s.result.forEach(d=>{d.key===this.LAST_SYNC_KEY?o.lastSync=d.value:d.key===this.DATA_JSON_HASH_KEY?o.dataJsonHash=d.value:d.key===this.INGREDIENTS_COUNT_KEY&&(o.ingredientsCount=d.value)}),console.log(`[RecipeDataIDBCache] Metadata: count=${o.ingredientsCount}, hash=${o.dataJsonHash?.slice(0,8)}...`),e(o)},s.onerror=()=>t(s.error)})}async saveAll(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,i)=>{const a=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE],"readwrite"),s=a.objectStore(this.INGREDIENTS_STORE);s.clear(),e.ingredients.forEach(d=>{s.put(d)}),a.objectStore(this.RECIPE_INFO_STORE).put(e.recipeInfo,this.RECIPE_INFO_KEY),a.oncomplete=()=>{console.log(`[RecipeDataIDBCache] ✓ ${e.ingredients.size} ingrédients + recipe-info sauvegardés`),t()},a.onerror=()=>i(a.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,i)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite"),s=a.objectStore(this.METADATA_STORE);s.put({key:this.LAST_SYNC_KEY,value:e.lastSync}),s.put({key:this.DATA_JSON_HASH_KEY,value:e.dataJsonHash}),s.put({key:this.INGREDIENTS_COUNT_KEY,value:e.ingredientsCount}),a.oncomplete=()=>{console.log("[RecipeDataIDBCache] ✓ Metadata sauvegardées"),t()},a.onerror=()=>i(a.error)})}async updateDataJsonHash(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,i)=>{const o=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.DATA_JSON_HASH_KEY,value:e});o.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Hash mis à jour: ${e?.slice(0,8)||"null"}`),t()},o.onerror=()=>i(o.error)})}async upsertIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,i)=>{const o=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).put(e);o.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient upsert: ${e.n}`),t()},o.onerror=()=>i(o.error)})}async deleteIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,i)=>{const o=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).delete(e);o.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient supprimé: ${e}`),t()},o.onerror=()=>i(o.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const i=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE,this.METADATA_STORE],"readwrite");i.objectStore(this.INGREDIENTS_STORE).clear(),i.objectStore(this.RECIPE_INFO_STORE).clear(),i.objectStore(this.METADATA_STORE).clear(),i.oncomplete=()=>{console.log("[RecipeDataIDBCache] Cache vidé"),e()},i.onerror=()=>t(i.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[RecipeDataIDBCache] Connexion fermée"))}}_=new WeakSet,P=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.INGREDIENTS_STORE,"readonly").objectStore(this.INGREDIENTS_STORE).getAll();s.onsuccess=()=>{const o=new Map;s.result.forEach(d=>{o.set(d.u,d)}),console.log(`[RecipeDataIDBCache] ${o.size} ingrédients chargés`),e(o)},s.onerror=()=>t(s.error)})},J=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.RECIPE_INFO_STORE,"readonly").objectStore(this.RECIPE_INFO_STORE).get(this.RECIPE_INFO_KEY);s.onsuccess=()=>{const o=s.result||{materiel:[],categories:[],regimes:[]};console.log(`[RecipeDataIDBCache] recipe-info chargé: ${o.categories?.length||0} catégories`),e(o)},s.onerror=()=>t(s.error)})};async function K(){const n=new k;return await n.open(),n}function M(n){return{materiel:[...n.materiel],categories:[...n.categories],regimes:[...n.regimes]}}const z="/data/ingredients.json",q="/data/recipe-info.json";var g,l,f,w,T,I,c,A,R,j,x,y;class L{constructor(){p(this,R);p(this,g,new C);p(this,l,O(G({materiel:[],categories:[],regimes:[]})));p(this,f,O(!1));p(this,w,O(null));p(this,T,O(null));p(this,I,O(!1));p(this,c,null);p(this,A,Y(()=>Array.from(r(this,g).values()).map(e=>e.n).sort()))}get loading(){return h(r(this,f))}get error(){return h(r(this,w))}get lastSync(){return h(r(this,T))}get isInitialized(){return h(r(this,I))}get ingredients(){return Array.from(r(this,g).values())}get count(){return r(this,g).size}get ingredientNames(){return h(r(this,A))}get materiel(){return h(r(this,l)).materiel}get categories(){return h(r(this,l)).categories}get regimes(){return h(r(this,l)).regimes}async initialize(){if(h(r(this,I))){console.log("[RecipeDataStore] Déjà initialisé");return}console.log("[RecipeDataStore] Initialisation..."),u(r(this,f),!0),u(r(this,w),null);try{m(this,c,await K());const e=await r(this,c).loadAll(),t=await r(this,c).loadMetadata();e.ingredients.size>0&&(console.log(`[RecipeDataStore] Cache: ${e.ingredients.size} ingrédients`),m(this,g,new C(e.ingredients)),u(r(this,l),e.recipeInfo,!0),u(r(this,T),t.lastSync,!0)),await D(this,R,j).call(this),u(r(this,I),!0),console.log(`[RecipeDataStore] ✓ ${r(this,g).size} ingrédients, ${h(r(this,l)).categories.length} catégories`)}catch(e){const t=e instanceof Error?e.message:"Erreur initialisation";throw u(r(this,w),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{u(r(this,f),!1)}}getIngredientByUuid(e){return r(this,g).get(e)||null}searchIngredients(e){if(!e.trim())return this.ingredients;const t=e.toLowerCase();return this.ingredients.filter(i=>i.n.toLowerCase().includes(t))}getIngredientsByType(e){return this.ingredients.filter(t=>t.t===e)}get availableTypes(){const e=new Set;return this.ingredients.forEach(t=>e.add(t.t)),Array.from(e).sort()}getIngredientsByAllergen(e){return this.ingredients.filter(t=>t.a?.includes(e))}get availableAllergens(){const e=new Set;return this.ingredients.forEach(t=>{t.a?.forEach(i=>e.add(i))}),Array.from(e).sort()}async addIngredient(e){if(!h(r(this,I)))throw new Error("Store non initialisé");try{console.log("[RecipeDataStore] Ajout ingrédient:",e.name);const{functions:t}=await v(),i=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"add_ingredient",data:{name:e.name,type:e.type,allergens:e.allergens,pF:e.pF,pS:e.pS,saisons:e.saisons}}),async:!1}),a=JSON.parse(i.responseBody);if(!a.success)throw new Error(a.error||"Erreur lors de la création de l'ingrédient");const s=a.ingredient;return r(this,g).set(s.u,s),r(this,c)&&await r(this,c).upsertIngredient(s),r(this,c)&&await r(this,c).updateDataJsonHash(null),console.log(`[RecipeDataStore] ✓ Ingrédient ajouté: ${s.n} (${s.u})`),s}catch(t){throw console.error("[RecipeDataStore] Erreur ajout ingrédient:",t),t}}async addCategory(e){if(h(r(this,l)).categories.includes(e)){console.warn(`[RecipeDataStore] Catégorie déjà existante: ${e}`);return}await D(this,R,y).call(this,{...h(r(this,l)),categories:[...h(r(this,l)).categories,e].sort()})}async addMateriel(e){if(h(r(this,l)).materiel.includes(e)){console.warn(`[RecipeDataStore] Matériel déjà existant: ${e}`);return}await D(this,R,y).call(this,{...h(r(this,l)),materiel:[...h(r(this,l)).materiel,e].sort()})}async addRegime(e){if(h(r(this,l)).regimes.includes(e)){console.warn(`[RecipeDataStore] Régime déjà existant: ${e}`);return}await D(this,R,y).call(this,{...h(r(this,l)),regimes:[...h(r(this,l)).regimes,e].sort()})}async forceReload(){console.log("[RecipeDataStore] Rechargement forcé..."),u(r(this,f),!0),u(r(this,w),null);try{r(this,c)&&await r(this,c).updateDataJsonHash(null),await D(this,R,j).call(this),console.log("[RecipeDataStore] ✓ Rechargement complété")}catch(e){const t=e instanceof Error?e.message:"Erreur rechargement";throw u(r(this,w),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{u(r(this,f),!1)}}async clearCache(){r(this,c)&&(await r(this,c).clear(),console.log("[RecipeDataStore] Cache vidé")),r(this,g).clear(),u(r(this,l),{materiel:[],categories:[],regimes:[]},!0),u(r(this,T),null),u(r(this,I),!1)}destroy(){r(this,c)&&(r(this,c).close(),m(this,c,null)),r(this,g).clear(),u(r(this,I),!1),console.log("[RecipeDataStore] Ressources nettoyées")}}g=new WeakMap,l=new WeakMap,f=new WeakMap,w=new WeakMap,T=new WeakMap,I=new WeakMap,c=new WeakMap,A=new WeakMap,R=new WeakSet,j=async function(){try{console.log("[RecipeDataStore] Fetch JSON...");const[e,t]=await Promise.all([fetch(z),fetch(q)]);if(!e.ok||!t.ok)throw new Error("Erreur HTTP lors du chargement des JSON");const[i,a]=await Promise.all([e.json(),t.json()]),s=await D(this,R,x).call(this,JSON.stringify(i)+JSON.stringify(a));if((await r(this,c).loadMetadata()).dataJsonHash===s){console.log("[RecipeDataStore] JSON inchangés, cache valide");return}console.log("[RecipeDataStore] Mise à jour depuis JSON...");const d=new Map;i.forEach(E=>{d.set(E.u,E)}),m(this,g,new C(d)),u(r(this,l),a,!0),u(r(this,T),new Date().toISOString(),!0),r(this,c)&&(await r(this,c).saveAll({ingredients:d,recipeInfo:M(h(r(this,l)))}),await r(this,c).saveMetadata({lastSync:h(r(this,T)),dataJsonHash:s,ingredientsCount:d.size})),console.log(`[RecipeDataStore] ✓ Cache mis à jour (hash: ${s.slice(0,8)}...)`)}catch(e){throw console.error("[RecipeDataStore] Erreur chargement JSON:",e),e}},x=async function(e){const i=new TextEncoder().encode(e),a=await crypto.subtle.digest("SHA-256",i);return Array.from(new Uint8Array(a)).map(o=>o.toString(16).padStart(2,"0")).join("")},y=async function(e){try{console.log("[RecipeDataStore] Mise à jour recipe-info...");const{functions:t}=await v(),i=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"update_recipe_info",data:e}),async:!1}),a=JSON.parse(i.responseBody);if(!a.success)throw new Error(a.error||"Erreur lors de la mise à jour du recipe-info");u(r(this,l),e,!0),r(this,c)&&(await r(this,c).saveAll({ingredients:new Map(r(this,g)),recipeInfo:M(e)}),await r(this,c).updateDataJsonHash(null)),console.log("[RecipeDataStore] ✓ recipe-info mis à jour")}catch(t){throw console.error("[RecipeDataStore] Erreur MAJ recipe-info:",t),t}};const W=new L;export{W as r};
