var to=Object.defineProperty;var Yn=s=>{throw TypeError(s)};var no=(s,e,t)=>e in s?to(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var C=(s,e,t)=>no(s,typeof e!="symbol"?e+"":e,t),bn=(s,e,t)=>e.has(s)||Yn("Cannot "+t);var i=(s,e,t)=>(bn(s,e,"read from private field"),t?t.call(s):e.get(s)),I=(s,e,t)=>e.has(s)?Yn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(s):e.set(s,t),j=(s,e,t,n)=>(bn(s,e,"write to private field"),n?n.call(s,t):e.set(s,t),t),S=(s,e,t)=>(bn(s,e,"access private method"),t);import{s as N,p as ce,g as p,a as m,S as st,u as z,M as Xn,n as so,e as oo,b as ro,c as nn,d as io}from"./vendor.js";const ao="modulepreload",co=function(s){return"/"+s},Zn={},En=function(e,t,n){let o=Promise.resolve();if(t&&t.length>0){let l=function(u){return Promise.all(u.map(d=>Promise.resolve(d).then(h=>({status:"fulfilled",value:h}),h=>({status:"rejected",reason:h}))))};document.getElementsByTagName("link");const a=document.querySelector("meta[property=csp-nonce]"),c=a?.nonce||a?.getAttribute("nonce");o=l(t.map(u=>{if(u=co(u),u in Zn)return;Zn[u]=!0;const d=u.endsWith(".css"),h=d?'[rel="stylesheet"]':"";if(document.querySelector(`link[href="${u}"]${h}`))return;const y=document.createElement("link");if(y.rel=d?"stylesheet":ao,d||(y.as="script"),y.crossOrigin="",y.href=u,c&&y.setAttribute("nonce",c),document.head.appendChild(y),d)return new Promise((w,E)=>{y.addEventListener("load",w),y.addEventListener("error",()=>E(new Error(`Unable to preload CSS for ${u}`)))})}))}function r(a){const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=a,window.dispatchEvent(c),!c.defaultPrevented)throw a}return o.then(a=>{for(const c of a||[])c.status==="rejected"&&r(c.reason);return e().catch(r)})};function Es(s,e){switch(e){case"kg":case"l.":return Math.round(s*100)/100;case"gr.":case"ml":return Math.round(s);default:return Math.round(s*10)/10}}function me(s){return s?.length?s.map(e=>He(e.q,e.u)).join(" et "):"-"}function lo(s,e){const t=typeof s=="number"?s:parseFloat(s);if(isNaN(t))return{value:0,unit:e};let n=e,o=t;return(e==="gr."||e==="ml")&&t>=1e3?(o=t/1e3,n=e==="gr."?"kg":"l."):(e==="kg"||e==="l.")&&t<1&&t>0&&(o=t*1e3,n=e==="kg"?"gr.":"ml"),{value:Es(o,n),unit:n}}function He(s,e){const{value:t,unit:n}=lo(s,e);let o;return n==="kg"||n==="l."?o=t.toFixed(2).replace(/\.?0+$/,""):o=t.toString(),`${o} ${n}`}function Xr(s,e,t){if(e==="au goût")return{quantity:s,unit:e,formatted:`${s} ${e}`,formattedNumber:`${s}`};const n=s*t,{q:o,u:r}=uo(n,e),a=Es(o,r);let c=`${a}`;return(r==="kg"||r==="l.")&&(c=a.toFixed(2).replace(/\.?0+$/,"")),{quantity:a,unit:r,formatted:`${c} ${r}`,formattedNumber:c}}function uo(s,e){const t=e.toLowerCase().trim();return(t==="gr."||t==="ml")&&s>=1e3?{q:s/1e3,u:t==="gr."?"kg":"l."}:(t==="kg"||t==="l.")&&s<1&&s>0?{q:s*1e3,u:t==="kg"?"gr.":"ml"}:{q:s,u:e}}function Tn(s){if(!s?.length)return[];const e=new Map;return s.forEach(({q:t,u:n})=>{if(typeof t=="number"&&!isNaN(t)){const o=e.get(n)||0;e.set(n,o+t)}}),Array.from(e.entries()).map(([t,n])=>({q:n,u:t}))}function po(s,e){const t=new Map,n=new Map;s.forEach(({q:a,u:c})=>{t.set(c,(t.get(c)||0)+a)}),e.forEach(({q:a,u:c})=>{n.set(c,(n.get(c)||0)+a)});const o=[],r=new Set([...t.keys(),...n.keys()]);for(const a of r){const c=t.get(a)||0,l=n.get(a)||0,u=c-l;Math.abs(u)>.001&&o.push({q:u,u:a})}return o}function ke(s){if(!s?.trim())return null;try{return JSON.parse(s)}catch(e){return console.warn("[ProductsStore] Erreur parsing JSON:",e),null}}function _n(s){return s?.length?s.filter(e=>e.quantity!=null&&e.unit).map(e=>({q:typeof e.quantity=="number"?e.quantity:parseFloat(e.quantity),u:e.unit})).filter(e=>!isNaN(e.q)):[]}function Nn(s){if(!s?.length)return[];const e=new Map;return s.forEach(t=>{if(!t.q||!t.u||typeof t.q!="number"||isNaN(t.q))return;const n=e.get(t.u)||0;e.set(t.u,n+t.q)}),Array.from(e.entries()).map(([t,n])=>({q:n,u:t}))}function yn(s,e){if(!s?.length)return{numeric:[],display:"✅ Complet"};if(!e?.length){const c=s.map(l=>He(l.q,l.u)).join(" et ");return{numeric:s,display:c}}const t=new Map,n=new Map;s.forEach(c=>{const l=parseFloat(c.q);isNaN(l)||t.set(c.u,(t.get(c.u)||0)+l)}),e.forEach(c=>{n.set(c.u,(n.get(c.u)||0)+c.q)});const o=[],r=[];t.forEach((c,l)=>{const u=n.get(l)||0,d=c-u;d>0&&(o.push({q:d,u:l}),r.push(He(d,l)))});const a=r.length>0?r.join(" et "):"✅ Complet";return{numeric:o,display:a}}function ho(s){return s?Object.values(s).some(e=>e.recipes?.some(t=>t.q!==void 0||t.u!==void 0)):!1}function Zr(s){if(!s)return[];const e=[];return Object.entries(s).forEach(([t,n])=>{n.recipes?.forEach(o=>{e.push({...o,date:t,dateTimeService:t})})}),e}function fo(s){if(!s?.length)return"Équilibré";const e=s.filter(n=>n.q>0),t=s.filter(n=>n.q<0);if(e.length>0&&t.length>0){const n=e.map(r=>He(r.q,r.u)).join(" et "),o=t.map(r=>He(Math.abs(r.q),r.u)).join(" et ");return`${n} disponibles, ${o} manquant${t.length>1?"s":""}`}else return e.length>0?e.map(n=>"+"+He(n.q,n.u)).join(" et ")+" disponibles":t.length>0?t.map(n=>He(Math.abs(n.q),n.u)).join(" et ")+` manquant${t.length>1?"s":""}`:"Équilibré"}function mo(s,e){if(e.searchQuery.trim()){const n=e.searchQuery.toLowerCase();if(!s.productName.toLowerCase().includes(n))return!1}if(e.selectedStores.length>0&&(!s.storeInfo?.storeName||!e.selectedStores.includes(s.storeInfo.storeName))||e.selectedWho.length>0&&(!s.who||!s.who.some(n=>e.selectedWho.includes(n)))||e.selectedProductTypes.length>0&&(!s.productType||!e.selectedProductTypes.includes(s.productType)))return!1;const t=e.temperatureFilter;if(t&&t!=="all")switch(t){case"frais":if(!s.pF)return!1;break;case"not-frais":if(s.pF)return!1;break;case"surgele":if(!s.pS)return!1;break;case"not-surgele":if(s.pS)return!1;break}return!0}function Ss(s){return s.toString().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/\s+/g,"-").replace(/[^\w\-]+/g,"").replace(/\-\-+/g,"-").replace(/^-+/,"").replace(/-+$/,"")}function yo(s,e,t=.01){if(!s?.length&&!e?.length)return!0;if(!s?.length||!e?.length)return!1;const n=new Map(s.map(c=>[c.u,c.q])),o=new Map(e.map(c=>[c.u,c.q])),r=Array.from(n.keys()).sort(),a=Array.from(o.keys()).sort();if(r.length!==a.length||!r.every((c,l)=>c===a[l]))return!1;for(const[c,l]of n){const u=o.get(c);if(u===void 0)return!1;const d=Math.abs(l-u),h=Math.max(l,u),y=Math.max(h*t,1);if(d>y)return!1}return!0}function Fr(s){const e=s.totalNeededOverrideParsed;if(!e)return{hasMismatch:!1,computedChanged:!1,platesChanged:!1,recipesChanged:!1};if(!(e.totalComputedWhenOverride!==void 0&&e.platesNbWhenOverride!==void 0&&e.recipesNbWhenOverride!==void 0))return{hasMismatch:!1,computedChanged:!1,platesChanged:!1,recipesChanged:!1};const n=e.totalComputedWhenOverride,o=s.totalNeededArray,r=e.platesNbWhenOverride,a=s.totalAssiettes,c=e.recipesNbWhenOverride,l=s.nbRecipes,u=!yo(n,o),d=r!==a,h=c!==l,y=u||d||h;return{hasMismatch:y,computedChanged:u,platesChanged:d,recipesChanged:h,details:y?{oldComputed:n,newComputed:o,oldPlates:r,newPlates:a,oldRecipes:c,newRecipes:l}:void 0}}function Fn(s){return{...s,products:s.products?.map(e=>typeof e=="string"?e:e.$id)||[],mainId:s.mainId}}class qn{static normalize(e,t,n=""){const o=t.toLowerCase(),r=n.toLowerCase(),a=o.includes("caf"),c=o.includes("soupe"),l=o.includes("pinc"),u=o.includes("gousse"),d=o.includes("tête"),h=o.includes("unit")||o==="pièce"||o==="piece",y=r.includes("sucre"),w=r.includes("sel"),E=r.includes("farine"),R=r.includes("crème épaisse")||r.includes("creme epaisse"),Q=r==="ail",V=r.includes("oignon"),L=r==="tomate",de=r==="poireau",en=r.includes("aubergine"),In=r==="courgette",tn=r==="échalote"||r==="echalote",Ks=r==="orange"&&!r.includes("jus"),Ys=r.includes("citron")&&!r.includes("jus"),Xs=r==="concombre",Zs=r==="levure chimique",Fs=r==="carotte",eo=r==="betterave rouge",Ln=r.includes("semoule"),xn=r.includes("poivre"),Bn=r.includes("cacao"),Hn=r.includes("sucre glace"),zn=r.includes("maizena")||r.includes("maïzena"),Wn=r.includes("bicarbonate"),Gn=r.includes("curcuma"),On=r.includes("cumin"),Qn=r.includes("curry"),Jn=r.includes("muscade"),Vn=r.includes("paprika"),Kn=r.includes("miel");let ge=e,Ye=t,pe=!1,xe="",M="";if(a){pe=!0;let v="cafe_default";M="ml",y?(v="cafe_sucre",M="gr."):w?(v="cafe_sel",M="gr."):E?(v="cafe_farine",M="gr."):Ln?(v="cafe_semoule",M="gr."):xn?(v="cafe_poivre",M="gr."):Bn?(v="cafe_cacao",M="gr."):Hn?(v="cafe_sucre_glace",M="gr."):zn?(v="cafe_maizena",M="gr."):Wn?(v="cafe_bicarbonate",M="gr."):Gn?(v="cafe_curcuma",M="gr."):On?(v="cafe_cumin",M="gr."):Qn?(v="cafe_curry",M="gr."):Jn?(v="cafe_muscade",M="gr."):Vn?(v="cafe_paprika",M="gr."):Kn?(v="cafe_miel",M="gr."):R&&(v="cafe_creme_epaisse",M="ml"),ge=e*this.CONVERSION_RULES[v],xe=`1 c. à café = ${this.CONVERSION_RULES[v]} ${M}`}else if(c){pe=!0;let v="soupe_default";M="ml",y?(v="soupe_sucre",M="gr."):w?(v="soupe_sel",M="gr."):E?(v="soupe_farine",M="gr."):Ln?(v="soupe_semoule",M="gr."):xn?(v="soupe_poivre",M="gr."):Bn?(v="soupe_cacao",M="gr."):Hn?(v="soupe_sucre_glace",M="gr."):zn?(v="soupe_maizena",M="gr."):R?(v="soupe_creme_epaisse",M="ml"):Wn?(v="soupe_bicarbonate",M="gr."):Gn?(v="soupe_curcuma",M="gr."):On?(v="soupe_cumin",M="gr."):Qn?(v="soupe_curry",M="gr."):Jn?(v="soupe_muscade",M="gr."):Vn?(v="soupe_paprika",M="gr."):Kn&&(v="soupe_miel",M="gr."),ge=e*this.CONVERSION_RULES[v],xe=`1 c. à soupe = ${this.CONVERSION_RULES[v]} ${M}`}else if(l)pe=!0,M="gr.",ge=e*this.CONVERSION_RULES.pincee,xe="1 pincée = 0.4 gr.";else if(u&&Q)pe=!0,M="gr.",ge=e*this.CONVERSION_RULES.gousse_ail,xe="1 gousse = 6.5 gr.";else if(d&&Q)pe=!0,M="gr.",ge=e*this.CONVERSION_RULES.tete_ail,xe="1 tête = 80 gr.";else if(h){pe=!0,M="gr.";let v="";V?v="unite_oignon":Q?v="unite_ail":L?v="unite_tomate":de?v="unite_poireau":en?v="unite_aubergine":In?v="unite_courgette":tn?v="unite_eshalote":Ks?v="unite_orange":Ys?v="unite_citron":Xs?v="unite_concombre":Zs?v="unite_levure_chimique":Fs?v="unite_carotte":eo?v="unite_betterave_rouge":pe=!1,pe&&(ge=e*this.CONVERSION_RULES[v],xe=`1 unité = ${this.CONVERSION_RULES[v]} gr.`)}return pe?Ye=M:o==="kg"?(ge=e*1e3,Ye="gr."):o==="l."?(ge=e*1e3,Ye="ml"):o==="gr."?Ye="gr.":o==="ml"&&(Ye="ml"),{quantity:ge,unit:Ye,originalUnit:t,ruleUsed:xe,hasConversion:pe}}}C(qn,"CONVERSION_RULES",{cafe_sucre:5,cafe_sel:5,cafe_farine:3,cafe_semoule:4,cafe_poivre:2.5,cafe_cacao:2.5,cafe_sucre_glace:3,cafe_maizena:3,cafe_bicarbonate:5,cafe_curcuma:2,cafe_cumin:2,cafe_curry:2,cafe_muscade:2,cafe_paprika:2,cafe_miel:10,cafe_creme_epaisse:5,cafe_default:5,soupe_sucre:15,soupe_sel:15,soupe_farine:10,soupe_semoule:12,soupe_poivre:8,soupe_cacao:8,soupe_sucre_glace:9,soupe_maizena:10,soupe_creme_epaisse:15,soupe_bicarbonate:15,soupe_curcuma:6,soupe_cumin:6,soupe_curry:6,soupe_muscade:7,soupe_paprika:6,soupe_miel:30,soupe_default:15,pincee:.4,gousse_ail:6.5,tete_ail:80,unite_oignon:120,unite_ail:6.5,unite_tomate:120,unite_poireau:150,unite_aubergine:250,unite_courgette:200,unite_eshalote:30,unite_orange:200,unite_citron:100,unite_concombre:200,unite_levure_chimique:11,unite_carotte:125,unite_betterave_rouge:250});const vs=2;function go(s){const t=new Date(s).getHours();return t>=11&&t<=13?"sun":t>=19&&t<=21?"moon":t>=7&&t<=9?"cloud":null}function wo(s){return{formattedDate:new Date(s).toLocaleDateString("fr-FR",{weekday:"short",day:"numeric"}),timeIcon:go(s)}}function Io(s){const e={};for(const t of s)e[t]=wo(t);return e}function bo(s,e,t){if(!s.byDate)return{requiredQuantities:[],requiredQuantitiesFormatted:"-",stockBalance:[],availableStockQuantities:[],missingStockQuantities:[],availableStockFormatted:"-",missingStockFormatted:"-",hasAvailableStock:!1,hasMissingStock:!1,totalRecipesInRange:0,totalPortionsInRange:0,datesInSelectedRange:[],recipesByDate:new Map};const n=new Date(e);n.setHours(0,0,0,0);const o=new Date(t);o.setHours(23,59,59,999);const r=[],a=new Map,c=new Map;let l=0,u=0;for(const[L,de]of Object.entries(s.byDate)){const en=new Date(L);en>=n&&en<=o&&(r.push(L),l+=de.totalAssiettes||0,de.recipes?.length&&(a.set(L,de.recipes),u+=de.recipes.length),de.totalConsolidated&&de.totalConsolidated.forEach(({q:In,u:tn})=>{c.set(tn,(c.get(tn)||0)+In)}))}const d=Array.from(c.entries()).map(([L,de])=>({q:de,u:L})),h=d.length>0?me(d):"-",y=s.totalNeededOverrideParsed?[s.totalNeededOverrideParsed.totalOverride]:d,w=Eo(s,e,t,y),E=w.filter(L=>L.q>0),R=new Date().toISOString().split("T")[0],V=t<R?[]:w.filter(L=>L.q<0);return{requiredQuantities:d,requiredQuantitiesFormatted:h,stockBalance:w,availableStockQuantities:E,missingStockQuantities:V,availableStockFormatted:fo(w),missingStockFormatted:me(V.map(L=>({q:Math.abs(L.q),u:L.u}))),hasAvailableStock:E.length>0,hasMissingStock:V.length>0,totalRecipesInRange:u,totalPortionsInRange:l,datesInSelectedRange:r,recipesByDate:a}}function Eo(s,e,t,n){let o=[],r="";s.stockParsed?.dateTime&&s.stockParsed.dateTime<=e&&(o=[{q:parseFloat(s.stockParsed.quantity),u:s.stockParsed.unit}],r=s.stockParsed.dateTime);const a=[];if(s.purchases)for(const u of s.purchases)So(u,e,t,r)&&a.push({q:u.quantity,u:u.unit});const c=[...o,...a],l=Tn(c);return po(l,n)}function So(s,e,t,n=""){if(s.status==="cancelled")return!1;const o=s.deliveryDate||s.$createdAt;if(!o)return!1;const r=new Date(t);return r.setHours(r.getHours()+vs),!(r<new Date||o>r.toISOString()||n&&s.$createdAt<n)}function vo(s){const e=ke(s.specs)??null,t=Nn(_n(s.purchases??[]));let n=[];e?.quantity&&(n=[e.quantity]);const o=ke(s.totalNeededOverride),r=o?[o.totalOverride]:n,{numeric:a,display:c}=yn(r,t);let l=ke(s.stockReel)??null;if(l&&l.quantity&&l.unit){const y=qn.normalize(parseFloat(l.quantity),l.unit);l={...l,quantity:y.quantity,unit:y.unit}}const u=me(t),d=s.store?ke(s.store):null,h=l?`${l.quantity} ${l.unit}`:u;return{$id:s.$id,$createdAt:s.$createdAt,$updatedAt:s.$updatedAt,productHugoUuid:s.productHugoUuid||"",productName:s.productName,productType:s.productType||"none",pF:e?.pF??!1,pS:e?.pS??!1,nbRecipes:0,totalAssiettes:0,isSynced:s.isSynced,mainId:s.mainId,totalNeededRaw:[],status:s.status,who:s.who,store:s.store,stockReel:s.stockReel,previousNames:s.previousNames,isMerged:s.isMerged,mergedFrom:s.mergedFrom,mergeDate:s.mergeDate,mergeReason:s.mergeReason,mergedInto:s.mergedInto,totalNeededOverride:s.totalNeededOverride,purchases:s.purchases,specs:s.specs,byDate:{},storeInfo:d,stockParsed:l,specsParsed:e,totalNeededArray:n,totalPurchasesArray:t,missingQuantityArray:a,stockOrTotalPurchases:h,displayTotalNeeded:me(n),displayTotalPurchases:u,displayMissingQuantity:c,totalNeededOverrideParsed:o,displayTotalOverride:o?me([o.totalOverride]):"",dateDisplayInfo:{}}}function sn(s,e){const t=s.purchases??e.purchases,n=s.specs??e.specs,o=n?ke(n):e.specsParsed,r=Nn(_n(t??[])),a=me(r);let c=e.totalNeededArray;!e.productHugoUuid&&o?.quantity&&(c=[o.quantity]);const l=ke(s.totalNeededOverride??e.totalNeededOverride),u=l?[l.totalOverride]:c,{numeric:d,display:h}=yn(u,r),y=s.stockReel??e.stockReel;let w=y?ke(y):e.stockParsed;if(w&&w.quantity&&w.unit){const V=qn.normalize(parseFloat(w.quantity),w.unit);w={...w,quantity:V.quantity,unit:V.unit}}const E=s.store??e.store,R=E?ke(E):e.storeInfo,Q=w?`${w.quantity} ${w.unit}`:a;return s.purchases===void 0&&e.purchases?.length&&console.log(`[ProductsStore] Fusion intelligente : préservation de ${e.purchases.length} purchases pour ${e.productName}`),{...e,$updatedAt:s.$updatedAt,productName:s.productName??e.productName,productType:s.productType??e.productType,isSynced:s.isSynced??e.isSynced,mainId:s.mainId??e.mainId,pF:o?.pF??e.pF,pS:o?.pS??e.pS,status:s.status??e.status,who:s.who??e.who,store:E,stockReel:y,specs:n,purchases:t,previousNames:s.previousNames??e.previousNames,isMerged:s.isMerged??e.isMerged,mergedFrom:s.mergedFrom??e.mergedFrom,mergeDate:s.mergeDate??e.mergeDate,mergeReason:s.mergeReason??e.mergeReason,mergedInto:s.mergedInto??e.mergedInto,totalNeededOverride:s.totalNeededOverride??e.totalNeededOverride,storeInfo:R,stockParsed:w,specsParsed:o,totalNeededArray:c,totalPurchasesArray:r,missingQuantityArray:d,stockOrTotalPurchases:Q,displayTotalPurchases:a,displayMissingQuantity:h,displayTotalNeeded:me(c),totalNeededOverrideParsed:l,displayTotalOverride:l?me([l.totalOverride]):""}}function Ro(s){s.totalPurchasesArray=Nn(_n(s.purchases??[]));const e=s.totalNeededOverrideParsed?[s.totalNeededOverrideParsed.totalOverride]:s.totalNeededArray,{numeric:t,display:n}=yn(e,s.totalPurchasesArray);s.missingQuantityArray=t,s.displayMissingQuantity=n}async function es(s,e,t){console.log(`[productEnrichment] Calcul pour événement ${s.$id} avec ${s.meals.length} repas`);const n=new Map;for(const r of s.meals)await Ao(r,e,n);const o=[];for(const[r,a]of n)o.push(Po(a,t));return console.log(`[productEnrichment] ${o.length} produits calculés`),o}async function Ao(s,e,t){const n=s.date;for(const o of s.recipes){const r=await e(o.recipeUuid);if(!r){console.warn(`[processMeal] Recette ${o.recipeUuid} introuvable`);continue}const a=o.plates/r.plate;for(const c of r.ingredients)To(c,a,n,t,r.title,o.plates)}}function To(s,e,t,n,o,r){const a=s.uuid;n.has(a)||n.set(a,{productHugoUuid:a,productName:s.name,productType:s.type,pF:s.pF??!1,pS:s.pS??!1,byDate:{},allergens:new Set(s.allergens||[])});const c=n.get(a),l=s.normalizedUnit==="au goût"?s.normalizedQuantity:s.normalizedQuantity*e,u=s.normalizedUnit==="au goût"?s.originalQuantity:s.originalQuantity*e;c.byDate[t]||(c.byDate[t]={quantities:[],recipes:[],totalAssiettes:0});const d=c.byDate[t];d.quantities.push({q:l,u:s.normalizedUnit}),d.recipes.push({r:o,q:u,u:s.originalUnit,qEq:l,uEq:s.normalizedUnit,a:r}),d.totalAssiettes+=r,s.allergens&&s.allergens.forEach(h=>c.allergens.add(h))}function Po(s,e){const t=Ss(s.productName).substring(0,20),n=e.slice(-10),o=`${t}_${n}`,r={};for(const[V,L]of Object.entries(s.byDate))r[V]={totalConsolidated:Tn(L.quantities),recipes:L.recipes,totalAssiettes:L.totalAssiettes,recipeCount:L.recipes.length};const a=Object.values(r).flatMap(V=>V.totalConsolidated),c=Tn(a),l=[],u=[],d=c,{numeric:h,display:y}=yn(d,l),w=Object.values(r).reduce((V,L)=>V+L.recipeCount,0),E=Object.values(r).reduce((V,L)=>V+L.totalAssiettes,0),R=Io(Object.keys(r));return{$id:o,mainId:e,productHugoUuid:s.productHugoUuid,productName:s.productName,productType:s.productType,byDate:r,totalNeededArray:c,totalPurchasesArray:l,missingQuantityArray:h,displayTotalNeeded:me(c),displayTotalPurchases:me(l),displayMissingQuantity:y,isSynced:!1,status:"active",who:[],store:"",storeInfo:null,purchases:u,stockReel:"",stockParsed:null,totalNeededOverride:null,totalNeededOverrideParsed:null,displayTotalOverride:"",stockOrTotalPurchases:"",previousNames:null,isMerged:!1,mergedFrom:[],mergeDate:null,mergeReason:null,mergedInto:null,specs:null,specsParsed:null,pF:s.pF??!1,pS:s.pS??!1,nbRecipes:w,totalAssiettes:E,totalNeededRaw:c,dateDisplayInfo:R,$createdAt:new Date().toISOString(),$updatedAt:new Date().toISOString(),$permissions:[],$databaseId:"",$tableId:""}}const $o={loading:0,success:2e3,info:3e3,warning:5e3,error:0},Do=2;var G,Je,Rs,Pn;class Mo{constructor(){I(this,Je);I(this,G,N(ce([])));C(this,"MAX_TOASTS",3)}get toasts(){return[...p(i(this,G))].sort((e,t)=>t.timestamp-e.timestamp)}create(e){const t=e.id||crypto.randomUUID(),n={id:t,state:e.state,message:e.message,timestamp:Date.now(),source:e.source||"user",position:e.position,timeoutId:void 0,autoCloseDelay:e.autoCloseDelay,details:e.details,actions:e.actions||[]};return S(this,Je,Rs).call(this,n),t}update(e,t){const n=p(i(this,G)).findIndex(r=>r.id===e);if(n===-1)return;const o=p(i(this,G))[n];o.timeoutId&&clearTimeout(o.timeoutId),p(i(this,G))[n]={...o,state:t.state||o.state,message:t.message||o.message,source:t.source||o.source,position:t.position||o.position,actions:t.actions||o.actions,autoCloseDelay:t.autoCloseDelay!==void 0?t.autoCloseDelay:o.autoCloseDelay},S(this,Je,Pn).call(this,p(i(this,G))[n])}async track(e,t){const n=this.create({id:t.id,state:"loading",message:t.loading,source:"user",position:t.position});try{const o=await e;return this.update(n,{state:"success",message:t.success||"Opération réussie",autoCloseDelay:t.successDelay}),o}catch(o){throw this.update(n,{state:"error",message:t.error||"Erreur lors de l'opération",autoCloseDelay:t.errorDelay}),o}}dismiss(e){const t=p(i(this,G)).findIndex(o=>o.id===e);if(t===-1)return;const n=p(i(this,G))[t];n.timeoutId&&clearTimeout(n.timeoutId),p(i(this,G)).splice(t,1)}dismissAll(){p(i(this,G)).forEach(e=>{e.timeoutId&&clearTimeout(e.timeoutId)}),m(i(this,G),[],!0)}success(e,t){return this.create({state:"success",message:e,details:t?.details,autoCloseDelay:t?.autoCloseDelay,position:t?.position})}error(e,t){return this.create({state:"error",message:e,details:t?.details,autoCloseDelay:t?.autoCloseDelay,position:t?.position})}warning(e,t){return this.create({state:"warning",message:e,source:t?.source||"system",details:t?.details,actions:t?.actions,autoCloseDelay:t?.autoCloseDelay,position:t?.position})}info(e,t){return this.create({state:"info",message:e,source:t?.source||"system",details:t?.details,autoCloseDelay:t?.autoCloseDelay,position:t?.position})}loading(e,t){return this.create({state:"loading",message:e,details:t?.details,autoCloseDelay:t?.autoCloseDelay,position:t?.position})}}G=new WeakMap,Je=new WeakSet,Rs=function(e){const t=p(i(this,G)).findIndex(n=>n.source===e.source);if(t>=0){const n=p(i(this,G))[t];n.timeoutId&&clearTimeout(n.timeoutId),p(i(this,G))[t]=e}else if(p(i(this,G)).length<this.MAX_TOASTS)p(i(this,G)).push(e);else{const n=p(i(this,G))[0];n.timeoutId&&clearTimeout(n.timeoutId),p(i(this,G)).shift(),p(i(this,G)).push(e)}S(this,Je,Pn).call(this,e)},Pn=function(e){e.timeoutId&&clearTimeout(e.timeoutId);let t;if(e.autoCloseDelay!==void 0)t=e.autoCloseDelay===0?void 0:e.autoCloseDelay;else{const n=$o[e.state];e.source==="realtime-other"&&n>0?t=n*Do:t=n===0?void 0:n}t!==void 0&&(e.timeoutId=setTimeout(()=>{this.dismiss(e.id)},t))};const Se=new Mo;function Sn(s,e,t,n){function o(r){return r instanceof t?r:new t(function(a){a(r)})}return new(t||(t=Promise))(function(r,a){function c(d){try{u(n.next(d))}catch(h){a(h)}}function l(d){try{u(n.throw(d))}catch(h){a(h)}}function u(d){d.done?r(d.value):o(d.value).then(c,l)}u((n=n.apply(s,[])).next())})}function Co(s,e,t,n){if(typeof e=="function"?s!==e||!n:!e.has(s))throw new TypeError("Cannot read private member from an object whose class did not declare it");return t==="m"?n:t==="a"?n.call(s):n?n.value:e.get(s)}class g{constructor(e,t,n){this.method=e,this.attribute=t,n!==void 0&&(Array.isArray(n)?this.values=n:this.values=[n])}toString(){return JSON.stringify({method:this.method,attribute:this.attribute,values:this.values})}}g.equal=(s,e)=>new g("equal",s,e).toString();g.notEqual=(s,e)=>new g("notEqual",s,e).toString();g.lessThan=(s,e)=>new g("lessThan",s,e).toString();g.lessThanEqual=(s,e)=>new g("lessThanEqual",s,e).toString();g.greaterThan=(s,e)=>new g("greaterThan",s,e).toString();g.greaterThanEqual=(s,e)=>new g("greaterThanEqual",s,e).toString();g.isNull=s=>new g("isNull",s).toString();g.isNotNull=s=>new g("isNotNull",s).toString();g.between=(s,e,t)=>new g("between",s,[e,t]).toString();g.startsWith=(s,e)=>new g("startsWith",s,e).toString();g.endsWith=(s,e)=>new g("endsWith",s,e).toString();g.select=s=>new g("select",void 0,s).toString();g.search=(s,e)=>new g("search",s,e).toString();g.orderDesc=s=>new g("orderDesc",s).toString();g.orderAsc=s=>new g("orderAsc",s).toString();g.orderRandom=()=>new g("orderRandom").toString();g.cursorAfter=s=>new g("cursorAfter",void 0,s).toString();g.cursorBefore=s=>new g("cursorBefore",void 0,s).toString();g.limit=s=>new g("limit",void 0,s).toString();g.offset=s=>new g("offset",void 0,s).toString();g.contains=(s,e)=>new g("contains",s,e).toString();g.notContains=(s,e)=>new g("notContains",s,e).toString();g.notSearch=(s,e)=>new g("notSearch",s,e).toString();g.notBetween=(s,e,t)=>new g("notBetween",s,[e,t]).toString();g.notStartsWith=(s,e)=>new g("notStartsWith",s,e).toString();g.notEndsWith=(s,e)=>new g("notEndsWith",s,e).toString();g.createdBefore=s=>g.lessThan("$createdAt",s);g.createdAfter=s=>g.greaterThan("$createdAt",s);g.createdBetween=(s,e)=>g.between("$createdAt",s,e);g.updatedBefore=s=>g.lessThan("$updatedAt",s);g.updatedAfter=s=>g.greaterThan("$updatedAt",s);g.updatedBetween=(s,e)=>g.between("$updatedAt",s,e);g.or=s=>new g("or",void 0,s.map(e=>JSON.parse(e))).toString();g.and=s=>new g("and",void 0,s.map(e=>JSON.parse(e))).toString();g.distanceEqual=(s,e,t,n=!0)=>new g("distanceEqual",s,[[e,t,n]]).toString();g.distanceNotEqual=(s,e,t,n=!0)=>new g("distanceNotEqual",s,[[e,t,n]]).toString();g.distanceGreaterThan=(s,e,t,n=!0)=>new g("distanceGreaterThan",s,[[e,t,n]]).toString();g.distanceLessThan=(s,e,t,n=!0)=>new g("distanceLessThan",s,[[e,t,n]]).toString();g.intersects=(s,e)=>new g("intersects",s,[e]).toString();g.notIntersects=(s,e)=>new g("notIntersects",s,[e]).toString();g.crosses=(s,e)=>new g("crosses",s,[e]).toString();g.notCrosses=(s,e)=>new g("notCrosses",s,[e]).toString();g.overlaps=(s,e)=>new g("overlaps",s,[e]).toString();g.notOverlaps=(s,e)=>new g("notOverlaps",s,[e]).toString();g.touches=(s,e)=>new g("touches",s,[e]).toString();g.notTouches=(s,e)=>new g("notTouches",s,[e]).toString();class f extends Error{constructor(e,t=0,n="",o=""){super(e),this.name="AppwriteException",this.message=e,this.code=t,this.type=n,this.response=o}}class we{constructor(){this.config={endpoint:"https://cloud.appwrite.io/v1",endpointRealtime:"",project:"",jwt:"",locale:"",session:"",devkey:""},this.headers={"x-sdk-name":"Web","x-sdk-platform":"client","x-sdk-language":"web","x-sdk-version":"21.4.0","X-Appwrite-Response-Format":"1.8.0"},this.realtime={socket:void 0,timeout:void 0,heartbeat:void 0,url:"",channels:new Set,subscriptions:new Map,subscriptionsCounter:0,reconnect:!0,reconnectAttempts:0,lastMessage:void 0,connect:()=>{clearTimeout(this.realtime.timeout),this.realtime.timeout=window?.setTimeout(()=>{this.realtime.createSocket()},50)},getTimeout:()=>{switch(!0){case this.realtime.reconnectAttempts<5:return 1e3;case this.realtime.reconnectAttempts<15:return 5e3;case this.realtime.reconnectAttempts<100:return 1e4;default:return 6e4}},createHeartbeat:()=>{this.realtime.heartbeat&&clearTimeout(this.realtime.heartbeat),this.realtime.heartbeat=window?.setInterval(()=>{var e;(e=this.realtime.socket)===null||e===void 0||e.send(JSON.stringify({type:"ping"}))},2e4)},createSocket:()=>{var e,t,n;if(this.realtime.channels.size<1){this.realtime.reconnect=!1,(e=this.realtime.socket)===null||e===void 0||e.close();return}const o=new URLSearchParams;this.config.project&&o.set("project",this.config.project),this.realtime.channels.forEach(a=>{o.append("channels[]",a)});const r=this.config.endpointRealtime+"/realtime?"+o.toString();(r!==this.realtime.url||!this.realtime.socket||((t=this.realtime.socket)===null||t===void 0?void 0:t.readyState)>WebSocket.OPEN)&&(this.realtime.socket&&((n=this.realtime.socket)===null||n===void 0?void 0:n.readyState)<WebSocket.CLOSING&&(this.realtime.reconnect=!1,this.realtime.socket.close()),this.realtime.url=r,this.realtime.socket=new WebSocket(r),this.realtime.socket.addEventListener("message",this.realtime.onMessage),this.realtime.socket.addEventListener("open",a=>{this.realtime.reconnectAttempts=0,this.realtime.createHeartbeat()}),this.realtime.socket.addEventListener("close",a=>{var c,l,u;if(!this.realtime.reconnect||((l=(c=this.realtime)===null||c===void 0?void 0:c.lastMessage)===null||l===void 0?void 0:l.type)==="error"&&((u=this.realtime)===null||u===void 0?void 0:u.lastMessage.data).code===1008){this.realtime.reconnect=!0;return}const d=this.realtime.getTimeout();console.error(`Realtime got disconnected. Reconnect will be attempted in ${d/1e3} seconds.`,a.reason),setTimeout(()=>{this.realtime.reconnectAttempts++,this.realtime.createSocket()},d)}))},onMessage:e=>{var t,n;try{const o=JSON.parse(e.data);switch(this.realtime.lastMessage=o,o.type){case"connected":let r=this.config.session;if(!r){const l=JSON.parse((t=window.localStorage.getItem("cookieFallback"))!==null&&t!==void 0?t:"{}");r=l?.[`a_session_${this.config.project}`]}const a=o.data;r&&!a.user&&((n=this.realtime.socket)===null||n===void 0||n.send(JSON.stringify({type:"authentication",data:{session:r}})));break;case"event":let c=o.data;if(c?.channels){if(!c.channels.some(u=>this.realtime.channels.has(u)))return;this.realtime.subscriptions.forEach(u=>{c.channels.some(d=>u.channels.includes(d))&&setTimeout(()=>u.callback(c))})}break;case"pong":break;case"error":throw o.data;default:break}}catch(o){console.error(o)}},cleanUp:e=>{this.realtime.channels.forEach(t=>{e.includes(t)&&(Array.from(this.realtime.subscriptions).some(([o,r])=>r.channels.includes(t))||this.realtime.channels.delete(t))})}}}setEndpoint(e){if(!e.startsWith("http://")&&!e.startsWith("https://"))throw new f("Invalid endpoint URL: "+e);return this.config.endpoint=e,this.config.endpointRealtime=e.replace("https://","wss://").replace("http://","ws://"),this}setEndpointRealtime(e){if(!e.startsWith("ws://")&&!e.startsWith("wss://"))throw new f("Invalid realtime endpoint URL: "+e);return this.config.endpointRealtime=e,this}setProject(e){return this.headers["X-Appwrite-Project"]=e,this.config.project=e,this}setJWT(e){return this.headers["X-Appwrite-JWT"]=e,this.config.jwt=e,this}setLocale(e){return this.headers["X-Appwrite-Locale"]=e,this.config.locale=e,this}setSession(e){return this.headers["X-Appwrite-Session"]=e,this.config.session=e,this}setDevKey(e){return this.headers["X-Appwrite-Dev-Key"]=e,this.config.devkey=e,this}subscribe(e,t){let n=typeof e=="string"?[e]:e;n.forEach(r=>this.realtime.channels.add(r));const o=this.realtime.subscriptionsCounter++;return this.realtime.subscriptions.set(o,{channels:n,callback:t}),this.realtime.connect(),()=>{this.realtime.subscriptions.delete(o),this.realtime.cleanUp(n),this.realtime.connect()}}prepareRequest(e,t,n={},o={}){if(e=e.toUpperCase(),n=Object.assign({},this.headers,n),typeof window<"u"&&window.localStorage){const a=window.localStorage.getItem("cookieFallback");a&&(n["X-Fallback-Cookies"]=a)}let r={method:e,headers:n};if(n["X-Appwrite-Dev-Key"]===void 0&&(r.credentials="include"),e==="GET")for(const[a,c]of Object.entries(we.flatten(o)))t.searchParams.append(a,c);else switch(n["content-type"]){case"application/json":r.body=JSON.stringify(o);break;case"multipart/form-data":const a=new FormData;for(const[c,l]of Object.entries(o))if(l instanceof File)a.append(c,l,l.name);else if(Array.isArray(l))for(const u of l)a.append(`${c}[]`,u);else a.append(c,l);r.body=a,delete n["content-type"];break}return{uri:t.toString(),options:r}}chunkedUpload(e,t,n={},o={},r){var a;return Sn(this,void 0,void 0,function*(){const[c,l]=(a=Object.entries(o).find(([h,y])=>y instanceof File))!==null&&a!==void 0?a:[];if(!l||!c)throw new Error("File not found in payload");if(l.size<=we.CHUNK_SIZE)return yield this.call(e,t,n,o);let u=0,d=null;for(;u<l.size;){let h=u+we.CHUNK_SIZE;h>=l.size&&(h=l.size),n["content-range"]=`bytes ${u}-${h-1}/${l.size}`;const y=l.slice(u,h);let w=Object.assign({},o);w[c]=new File([y],l.name),d=yield this.call(e,t,n,w),r&&typeof r=="function"&&r({$id:d.$id,progress:Math.round(h/l.size*100),sizeUploaded:h,chunksTotal:Math.ceil(l.size/we.CHUNK_SIZE),chunksUploaded:Math.ceil(h/we.CHUNK_SIZE)}),d&&d.$id&&(n["x-appwrite-id"]=d.$id),u=h}return d})}ping(){return Sn(this,void 0,void 0,function*(){return this.call("GET",new URL(this.config.endpoint+"/ping"))})}call(e,t,n={},o={},r="json"){var a,c;return Sn(this,void 0,void 0,function*(){const{uri:l,options:u}=this.prepareRequest(e,t,n,o);let d=null;const h=yield fetch(l,u);if(h.type==="opaque")throw new f(`Invalid Origin. Register your new client (${window.location.host}) as a new Web platform on your project console dashboard`,403,"forbidden","");const y=h.headers.get("x-appwrite-warning");if(y&&y.split(";").forEach(E=>console.warn("Warning: "+E)),!((a=h.headers.get("content-type"))===null||a===void 0)&&a.includes("application/json")?d=yield h.json():r==="arrayBuffer"?d=yield h.arrayBuffer():d={message:yield h.text()},400<=h.status){let E="";throw!((c=h.headers.get("content-type"))===null||c===void 0)&&c.includes("application/json")||r==="arrayBuffer"?E=JSON.stringify(d):E=d?.message,new f(d?.message,h.status,d?.type,E)}const w=h.headers.get("X-Fallback-Cookies");return typeof window<"u"&&window.localStorage&&w&&(window.console.warn("Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint."),window.localStorage.setItem("cookieFallback",w)),d})}static flatten(e,t=""){let n={};for(const[o,r]of Object.entries(e)){let a=t?t+"["+o+"]":o;Array.isArray(r)?n=Object.assign(Object.assign({},n),we.flatten(r,a)):n[a]=r}return n}}we.CHUNK_SIZE=1024*1024*5;class lt{constructor(e){this.client=e}static flatten(e,t=""){let n={};for(const[o,r]of Object.entries(e)){let a=t?t+"["+o+"]":o;Array.isArray(r)?n=Object.assign(Object.assign({},n),lt.flatten(r,a)):n[a]=r}return n}}lt.CHUNK_SIZE=5*1024*1024;class _o{constructor(e){this.client=e}get(){const e="/account",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}create(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,email:t[0],password:t[1],name:t[2]};const o=n.userId,r=n.email,a=n.password,c=n.name;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "email"');if(typeof a>"u")throw new f('Missing required parameter: "password"');const l="/account",u={};typeof o<"u"&&(u.userId=o),typeof r<"u"&&(u.email=r),typeof a<"u"&&(u.password=a),typeof c<"u"&&(u.name=c);const d=new URL(this.client.config.endpoint+l),h={"content-type":"application/json"};return this.client.call("post",d,h,u)}updateEmail(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={email:e,password:t[0]};const o=n.email,r=n.password;if(typeof o>"u")throw new f('Missing required parameter: "email"');if(typeof r>"u")throw new f('Missing required parameter: "password"');const a="/account/email",c={};typeof o<"u"&&(c.email=o),typeof r<"u"&&(c.password=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("patch",l,u,c)}listIdentities(e,...t){let n;!e||e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={queries:e,total:t[0]};const o=n.queries,r=n.total,a="/account/identities",c={};typeof o<"u"&&(c.queries=o),typeof r<"u"&&(c.total=r);const l=new URL(this.client.config.endpoint+a),u={};return this.client.call("get",l,u,c)}deleteIdentity(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={identityId:e};const n=t.identityId;if(typeof n>"u")throw new f('Missing required parameter: "identityId"');const o="/account/identities/{identityId}".replace("{identityId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}createJWT(){const e="/account/jwts",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("post",n,o,t)}listLogs(e,...t){let n;!e||e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={queries:e,total:t[0]};const o=n.queries,r=n.total,a="/account/logs",c={};typeof o<"u"&&(c.queries=o),typeof r<"u"&&(c.total=r);const l=new URL(this.client.config.endpoint+a),u={};return this.client.call("get",l,u,c)}updateMFA(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={mfa:e};const n=t.mfa;if(typeof n>"u")throw new f('Missing required parameter: "mfa"');const o="/account/mfa",r={};typeof n<"u"&&(r.mfa=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("patch",a,c,r)}createMfaAuthenticator(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?t=e||{}:t={type:e};const n=t.type;if(typeof n>"u")throw new f('Missing required parameter: "type"');const o="/account/mfa/authenticators/{type}".replace("{type}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}createMFAAuthenticator(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?t=e||{}:t={type:e};const n=t.type;if(typeof n>"u")throw new f('Missing required parameter: "type"');const o="/account/mfa/authenticators/{type}".replace("{type}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}updateMfaAuthenticator(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?n=e||{}:n={type:e,otp:t[0]};const o=n.type,r=n.otp;if(typeof o>"u")throw new f('Missing required parameter: "type"');if(typeof r>"u")throw new f('Missing required parameter: "otp"');const a="/account/mfa/authenticators/{type}".replace("{type}",o),c={};typeof r<"u"&&(c.otp=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}updateMFAAuthenticator(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?n=e||{}:n={type:e,otp:t[0]};const o=n.type,r=n.otp;if(typeof o>"u")throw new f('Missing required parameter: "type"');if(typeof r>"u")throw new f('Missing required parameter: "otp"');const a="/account/mfa/authenticators/{type}".replace("{type}",o),c={};typeof r<"u"&&(c.otp=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}deleteMfaAuthenticator(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?t=e||{}:t={type:e};const n=t.type;if(typeof n>"u")throw new f('Missing required parameter: "type"');const o="/account/mfa/authenticators/{type}".replace("{type}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}deleteMFAAuthenticator(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"type"in e?t=e||{}:t={type:e};const n=t.type;if(typeof n>"u")throw new f('Missing required parameter: "type"');const o="/account/mfa/authenticators/{type}".replace("{type}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}createMfaChallenge(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"factor"in e?t=e||{}:t={factor:e};const n=t.factor;if(typeof n>"u")throw new f('Missing required parameter: "factor"');const o="/account/mfa/challenge",r={};typeof n<"u"&&(r.factor=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}createMFAChallenge(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"factor"in e?t=e||{}:t={factor:e};const n=t.factor;if(typeof n>"u")throw new f('Missing required parameter: "factor"');const o="/account/mfa/challenge",r={};typeof n<"u"&&(r.factor=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}updateMfaChallenge(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={challengeId:e,otp:t[0]};const o=n.challengeId,r=n.otp;if(typeof o>"u")throw new f('Missing required parameter: "challengeId"');if(typeof r>"u")throw new f('Missing required parameter: "otp"');const a="/account/mfa/challenge",c={};typeof o<"u"&&(c.challengeId=o),typeof r<"u"&&(c.otp=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}updateMFAChallenge(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={challengeId:e,otp:t[0]};const o=n.challengeId,r=n.otp;if(typeof o>"u")throw new f('Missing required parameter: "challengeId"');if(typeof r>"u")throw new f('Missing required parameter: "otp"');const a="/account/mfa/challenge",c={};typeof o<"u"&&(c.challengeId=o),typeof r<"u"&&(c.otp=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}listMfaFactors(){const e="/account/mfa/factors",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}listMFAFactors(){const e="/account/mfa/factors",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}getMfaRecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}getMFARecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}createMfaRecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("post",n,o,t)}createMFARecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("post",n,o,t)}updateMfaRecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("patch",n,o,t)}updateMFARecoveryCodes(){const e="/account/mfa/recovery-codes",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("patch",n,o,t)}updateName(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={name:e};const n=t.name;if(typeof n>"u")throw new f('Missing required parameter: "name"');const o="/account/name",r={};typeof n<"u"&&(r.name=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("patch",a,c,r)}updatePassword(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={password:e,oldPassword:t[0]};const o=n.password,r=n.oldPassword;if(typeof o>"u")throw new f('Missing required parameter: "password"');const a="/account/password",c={};typeof o<"u"&&(c.password=o),typeof r<"u"&&(c.oldPassword=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("patch",l,u,c)}updatePhone(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={phone:e,password:t[0]};const o=n.phone,r=n.password;if(typeof o>"u")throw new f('Missing required parameter: "phone"');if(typeof r>"u")throw new f('Missing required parameter: "password"');const a="/account/phone",c={};typeof o<"u"&&(c.phone=o),typeof r<"u"&&(c.password=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("patch",l,u,c)}getPrefs(){const e="/account/prefs",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}updatePrefs(e){let t;e&&typeof e=="object"&&!Array.isArray(e)&&"prefs"in e?t=e||{}:t={prefs:e};const n=t.prefs;if(typeof n>"u")throw new f('Missing required parameter: "prefs"');const o="/account/prefs",r={};typeof n<"u"&&(r.prefs=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("patch",a,c,r)}createRecovery(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={email:e,url:t[0]};const o=n.email,r=n.url;if(typeof o>"u")throw new f('Missing required parameter: "email"');if(typeof r>"u")throw new f('Missing required parameter: "url"');const a="/account/recovery",c={};typeof o<"u"&&(c.email=o),typeof r<"u"&&(c.url=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}updateRecovery(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0],password:t[1]};const o=n.userId,r=n.secret,a=n.password;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');if(typeof a>"u")throw new f('Missing required parameter: "password"');const c="/account/recovery",l={};typeof o<"u"&&(l.userId=o),typeof r<"u"&&(l.secret=r),typeof a<"u"&&(l.password=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("put",u,d,l)}listSessions(){const e="/account/sessions",t={},n=new URL(this.client.config.endpoint+e),o={};return this.client.call("get",n,o,t)}deleteSessions(){const e="/account/sessions",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("delete",n,o,t)}createAnonymousSession(){const e="/account/sessions/anonymous",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("post",n,o,t)}createEmailPasswordSession(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={email:e,password:t[0]};const o=n.email,r=n.password;if(typeof o>"u")throw new f('Missing required parameter: "email"');if(typeof r>"u")throw new f('Missing required parameter: "password"');const a="/account/sessions/email",c={};typeof o<"u"&&(c.email=o),typeof r<"u"&&(c.password=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}updateMagicURLSession(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/sessions/magic-url",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}createOAuth2Session(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)&&"provider"in e?n=e||{}:n={provider:e,success:t[0],failure:t[1],scopes:t[2]};const o=n.provider,r=n.success,a=n.failure,c=n.scopes;if(typeof o>"u")throw new f('Missing required parameter: "provider"');const l="/account/sessions/oauth2/{provider}".replace("{provider}",o),u={};typeof r<"u"&&(u.success=r),typeof a<"u"&&(u.failure=a),typeof c<"u"&&(u.scopes=c);const d=new URL(this.client.config.endpoint+l);u.project=this.client.config.project;for(const[h,y]of Object.entries(lt.flatten(u)))d.searchParams.append(h,y);if(typeof window<"u"&&window?.location){window.location.href=d.toString();return}else return d.toString()}updatePhoneSession(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/sessions/phone",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}createSession(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/sessions/token",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}getSession(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={sessionId:e};const n=t.sessionId;if(typeof n>"u")throw new f('Missing required parameter: "sessionId"');const o="/account/sessions/{sessionId}".replace("{sessionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}updateSession(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={sessionId:e};const n=t.sessionId;if(typeof n>"u")throw new f('Missing required parameter: "sessionId"');const o="/account/sessions/{sessionId}".replace("{sessionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("patch",a,c,r)}deleteSession(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={sessionId:e};const n=t.sessionId;if(typeof n>"u")throw new f('Missing required parameter: "sessionId"');const o="/account/sessions/{sessionId}".replace("{sessionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}updateStatus(){const e="/account/status",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("patch",n,o,t)}createPushTarget(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={targetId:e,identifier:t[0],providerId:t[1]};const o=n.targetId,r=n.identifier,a=n.providerId;if(typeof o>"u")throw new f('Missing required parameter: "targetId"');if(typeof r>"u")throw new f('Missing required parameter: "identifier"');const c="/account/targets/push",l={};typeof o<"u"&&(l.targetId=o),typeof r<"u"&&(l.identifier=r),typeof a<"u"&&(l.providerId=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("post",u,d,l)}updatePushTarget(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={targetId:e,identifier:t[0]};const o=n.targetId,r=n.identifier;if(typeof o>"u")throw new f('Missing required parameter: "targetId"');if(typeof r>"u")throw new f('Missing required parameter: "identifier"');const a="/account/targets/{targetId}/push".replace("{targetId}",o),c={};typeof r<"u"&&(c.identifier=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}deletePushTarget(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={targetId:e};const n=t.targetId;if(typeof n>"u")throw new f('Missing required parameter: "targetId"');const o="/account/targets/{targetId}/push".replace("{targetId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}createEmailToken(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,email:t[0],phrase:t[1]};const o=n.userId,r=n.email,a=n.phrase;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "email"');const c="/account/tokens/email",l={};typeof o<"u"&&(l.userId=o),typeof r<"u"&&(l.email=r),typeof a<"u"&&(l.phrase=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("post",u,d,l)}createMagicURLToken(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,email:t[0],url:t[1],phrase:t[2]};const o=n.userId,r=n.email,a=n.url,c=n.phrase;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "email"');const l="/account/tokens/magic-url",u={};typeof o<"u"&&(u.userId=o),typeof r<"u"&&(u.email=r),typeof a<"u"&&(u.url=a),typeof c<"u"&&(u.phrase=c);const d=new URL(this.client.config.endpoint+l),h={"content-type":"application/json"};return this.client.call("post",d,h,u)}createOAuth2Token(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)&&"provider"in e?n=e||{}:n={provider:e,success:t[0],failure:t[1],scopes:t[2]};const o=n.provider,r=n.success,a=n.failure,c=n.scopes;if(typeof o>"u")throw new f('Missing required parameter: "provider"');const l="/account/tokens/oauth2/{provider}".replace("{provider}",o),u={};typeof r<"u"&&(u.success=r),typeof a<"u"&&(u.failure=a),typeof c<"u"&&(u.scopes=c);const d=new URL(this.client.config.endpoint+l);u.project=this.client.config.project;for(const[h,y]of Object.entries(lt.flatten(u)))d.searchParams.append(h,y);if(typeof window<"u"&&window?.location){window.location.href=d.toString();return}else return d.toString()}createPhoneToken(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,phone:t[0]};const o=n.userId,r=n.phone;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "phone"');const a="/account/tokens/phone",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.phone=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}createEmailVerification(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={url:e};const n=t.url;if(typeof n>"u")throw new f('Missing required parameter: "url"');const o="/account/verifications/email",r={};typeof n<"u"&&(r.url=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}createVerification(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={url:e};const n=t.url;if(typeof n>"u")throw new f('Missing required parameter: "url"');const o="/account/verifications/email",r={};typeof n<"u"&&(r.url=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}updateEmailVerification(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/verifications/email",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}updateVerification(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/verifications/email",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}createPhoneVerification(){const e="/account/verifications/phone",t={},n=new URL(this.client.config.endpoint+e),o={"content-type":"application/json"};return this.client.call("post",n,o,t)}updatePhoneVerification(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={userId:e,secret:t[0]};const o=n.userId,r=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "userId"');if(typeof r>"u")throw new f('Missing required parameter: "secret"');const a="/account/verifications/phone",c={};typeof o<"u"&&(c.userId=o),typeof r<"u"&&(c.secret=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}}class No{constructor(e){this.client=e}listTransactions(e){let t;!e||e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={queries:e};const n=t.queries,o="/databases/transactions",r={};typeof n<"u"&&(r.queries=n);const a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}createTransaction(e){let t;!e||e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={ttl:e};const n=t.ttl,o="/databases/transactions",r={};typeof n<"u"&&(r.ttl=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}getTransaction(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={transactionId:e};const n=t.transactionId;if(typeof n>"u")throw new f('Missing required parameter: "transactionId"');const o="/databases/transactions/{transactionId}".replace("{transactionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}updateTransaction(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={transactionId:e,commit:t[0],rollback:t[1]};const o=n.transactionId,r=n.commit,a=n.rollback;if(typeof o>"u")throw new f('Missing required parameter: "transactionId"');const c="/databases/transactions/{transactionId}".replace("{transactionId}",o),l={};typeof r<"u"&&(l.commit=r),typeof a<"u"&&(l.rollback=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("patch",u,d,l)}deleteTransaction(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={transactionId:e};const n=t.transactionId;if(typeof n>"u")throw new f('Missing required parameter: "transactionId"');const o="/databases/transactions/{transactionId}".replace("{transactionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}createOperations(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={transactionId:e,operations:t[0]};const o=n.transactionId,r=n.operations;if(typeof o>"u")throw new f('Missing required parameter: "transactionId"');const a="/databases/transactions/{transactionId}/operations".replace("{transactionId}",o),c={};typeof r<"u"&&(c.operations=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}listDocuments(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],queries:t[1],transactionId:t[2],total:t[3]};const o=n.databaseId,r=n.collectionId,a=n.queries,c=n.transactionId,l=n.total;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');const u="/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}",o).replace("{collectionId}",r),d={};typeof a<"u"&&(d.queries=a),typeof c<"u"&&(d.transactionId=c),typeof l<"u"&&(d.total=l);const h=new URL(this.client.config.endpoint+u),y={};return this.client.call("get",h,y,d)}createDocument(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');if(typeof c>"u")throw new f('Missing required parameter: "data"');const d="/databases/{databaseId}/collections/{collectionId}/documents".replace("{databaseId}",o).replace("{collectionId}",r),h={};typeof a<"u"&&(h.documentId=a),typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("post",y,w,h)}getDocument(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],queries:t[2],transactionId:t[3]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.queries,l=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');const u="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a),d={};typeof c<"u"&&(d.queries=c),typeof l<"u"&&(d.transactionId=l);const h=new URL(this.client.config.endpoint+u),y={};return this.client.call("get",h,y,d)}upsertDocument(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');if(typeof c>"u")throw new f('Missing required parameter: "data"');const d="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a),h={};typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("put",y,w,h)}updateDocument(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');const d="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a),h={};typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("patch",y,w,h)}deleteDocument(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],transactionId:t[2]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');const l="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a),u={};typeof c<"u"&&(u.transactionId=c);const d=new URL(this.client.config.endpoint+l),h={"content-type":"application/json"};return this.client.call("delete",d,h,u)}decrementDocumentAttribute(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],attribute:t[2],value:t[3],min:t[4],transactionId:t[5]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.attribute,l=n.value,u=n.min,d=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');if(typeof c>"u")throw new f('Missing required parameter: "attribute"');const h="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a).replace("{attribute}",c),y={};typeof l<"u"&&(y.value=l),typeof u<"u"&&(y.min=u),typeof d<"u"&&(y.transactionId=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("patch",w,E,y)}incrementDocumentAttribute(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,collectionId:t[0],documentId:t[1],attribute:t[2],value:t[3],max:t[4],transactionId:t[5]};const o=n.databaseId,r=n.collectionId,a=n.documentId,c=n.attribute,l=n.value,u=n.max,d=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "collectionId"');if(typeof a>"u")throw new f('Missing required parameter: "documentId"');if(typeof c>"u")throw new f('Missing required parameter: "attribute"');const h="/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment".replace("{databaseId}",o).replace("{collectionId}",r).replace("{documentId}",a).replace("{attribute}",c),y={};typeof l<"u"&&(y.value=l),typeof u<"u"&&(y.max=u),typeof d<"u"&&(y.transactionId=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("patch",w,E,y)}}class qo{constructor(e){this.client=e}listExecutions(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={functionId:e,queries:t[0],total:t[1]};const o=n.functionId,r=n.queries,a=n.total;if(typeof o>"u")throw new f('Missing required parameter: "functionId"');const c="/functions/{functionId}/executions".replace("{functionId}",o),l={};typeof r<"u"&&(l.queries=r),typeof a<"u"&&(l.total=a);const u=new URL(this.client.config.endpoint+c),d={};return this.client.call("get",u,d,l)}createExecution(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={functionId:e,body:t[0],async:t[1],xpath:t[2],method:t[3],headers:t[4],scheduledAt:t[5]};const o=n.functionId,r=n.body,a=n.async,c=n.xpath,l=n.method,u=n.headers,d=n.scheduledAt;if(typeof o>"u")throw new f('Missing required parameter: "functionId"');const h="/functions/{functionId}/executions".replace("{functionId}",o),y={};typeof r<"u"&&(y.body=r),typeof a<"u"&&(y.async=a),typeof c<"u"&&(y.path=c),typeof l<"u"&&(y.method=l),typeof u<"u"&&(y.headers=u),typeof d<"u"&&(y.scheduledAt=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("post",w,E,y)}getExecution(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={functionId:e,executionId:t[0]};const o=n.functionId,r=n.executionId;if(typeof o>"u")throw new f('Missing required parameter: "functionId"');if(typeof r>"u")throw new f('Missing required parameter: "executionId"');const a="/functions/{functionId}/executions/{executionId}".replace("{functionId}",o).replace("{executionId}",r),c={},l=new URL(this.client.config.endpoint+a),u={};return this.client.call("get",l,u,c)}}class jo{constructor(e){this.client=e}listTransactions(e){let t;!e||e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={queries:e};const n=t.queries,o="/tablesdb/transactions",r={};typeof n<"u"&&(r.queries=n);const a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}createTransaction(e){let t;!e||e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={ttl:e};const n=t.ttl,o="/tablesdb/transactions",r={};typeof n<"u"&&(r.ttl=n);const a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("post",a,c,r)}getTransaction(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={transactionId:e};const n=t.transactionId;if(typeof n>"u")throw new f('Missing required parameter: "transactionId"');const o="/tablesdb/transactions/{transactionId}".replace("{transactionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}updateTransaction(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={transactionId:e,commit:t[0],rollback:t[1]};const o=n.transactionId,r=n.commit,a=n.rollback;if(typeof o>"u")throw new f('Missing required parameter: "transactionId"');const c="/tablesdb/transactions/{transactionId}".replace("{transactionId}",o),l={};typeof r<"u"&&(l.commit=r),typeof a<"u"&&(l.rollback=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("patch",u,d,l)}deleteTransaction(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={transactionId:e};const n=t.transactionId;if(typeof n>"u")throw new f('Missing required parameter: "transactionId"');const o="/tablesdb/transactions/{transactionId}".replace("{transactionId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}createOperations(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={transactionId:e,operations:t[0]};const o=n.transactionId,r=n.operations;if(typeof o>"u")throw new f('Missing required parameter: "transactionId"');const a="/tablesdb/transactions/{transactionId}/operations".replace("{transactionId}",o),c={};typeof r<"u"&&(c.operations=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("post",l,u,c)}listRows(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],queries:t[1],transactionId:t[2],total:t[3]};const o=n.databaseId,r=n.tableId,a=n.queries,c=n.transactionId,l=n.total;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');const u="/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}",o).replace("{tableId}",r),d={};typeof a<"u"&&(d.queries=a),typeof c<"u"&&(d.transactionId=c),typeof l<"u"&&(d.total=l);const h=new URL(this.client.config.endpoint+u),y={};return this.client.call("get",h,y,d)}createRow(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');if(typeof c>"u")throw new f('Missing required parameter: "data"');const d="/tablesdb/{databaseId}/tables/{tableId}/rows".replace("{databaseId}",o).replace("{tableId}",r),h={};typeof a<"u"&&(h.rowId=a),typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("post",y,w,h)}getRow(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],queries:t[2],transactionId:t[3]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.queries,l=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');const u="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a),d={};typeof c<"u"&&(d.queries=c),typeof l<"u"&&(d.transactionId=l);const h=new URL(this.client.config.endpoint+u),y={};return this.client.call("get",h,y,d)}upsertRow(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');const d="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a),h={};typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("put",y,w,h)}updateRow(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],data:t[2],permissions:t[3],transactionId:t[4]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.data,l=n.permissions,u=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');const d="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a),h={};typeof c<"u"&&(h.data=c),typeof l<"u"&&(h.permissions=l),typeof u<"u"&&(h.transactionId=u);const y=new URL(this.client.config.endpoint+d),w={"content-type":"application/json"};return this.client.call("patch",y,w,h)}deleteRow(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],transactionId:t[2]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');const l="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a),u={};typeof c<"u"&&(u.transactionId=c);const d=new URL(this.client.config.endpoint+l),h={"content-type":"application/json"};return this.client.call("delete",d,h,u)}decrementRowColumn(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],column:t[2],value:t[3],min:t[4],transactionId:t[5]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.column,l=n.value,u=n.min,d=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');if(typeof c>"u")throw new f('Missing required parameter: "column"');const h="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a).replace("{column}",c),y={};typeof l<"u"&&(y.value=l),typeof u<"u"&&(y.min=u),typeof d<"u"&&(y.transactionId=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("patch",w,E,y)}incrementRowColumn(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={databaseId:e,tableId:t[0],rowId:t[1],column:t[2],value:t[3],max:t[4],transactionId:t[5]};const o=n.databaseId,r=n.tableId,a=n.rowId,c=n.column,l=n.value,u=n.max,d=n.transactionId;if(typeof o>"u")throw new f('Missing required parameter: "databaseId"');if(typeof r>"u")throw new f('Missing required parameter: "tableId"');if(typeof a>"u")throw new f('Missing required parameter: "rowId"');if(typeof c>"u")throw new f('Missing required parameter: "column"');const h="/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment".replace("{databaseId}",o).replace("{tableId}",r).replace("{rowId}",a).replace("{column}",c),y={};typeof l<"u"&&(y.value=l),typeof u<"u"&&(y.max=u),typeof d<"u"&&(y.transactionId=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("patch",w,E,y)}}class ko{constructor(e){this.client=e}list(e,...t){let n;!e||e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={queries:e,search:t[0],total:t[1]};const o=n.queries,r=n.search,a=n.total,c="/teams",l={};typeof o<"u"&&(l.queries=o),typeof r<"u"&&(l.search=r),typeof a<"u"&&(l.total=a);const u=new URL(this.client.config.endpoint+c),d={};return this.client.call("get",u,d,l)}create(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,name:t[0],roles:t[1]};const o=n.teamId,r=n.name,a=n.roles;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "name"');const c="/teams",l={};typeof o<"u"&&(l.teamId=o),typeof r<"u"&&(l.name=r),typeof a<"u"&&(l.roles=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("post",u,d,l)}get(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={teamId:e};const n=t.teamId;if(typeof n>"u")throw new f('Missing required parameter: "teamId"');const o="/teams/{teamId}".replace("{teamId}",n),r={},a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}updateName(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,name:t[0]};const o=n.teamId,r=n.name;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "name"');const a="/teams/{teamId}".replace("{teamId}",o),c={};typeof r<"u"&&(c.name=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}delete(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={teamId:e};const n=t.teamId;if(typeof n>"u")throw new f('Missing required parameter: "teamId"');const o="/teams/{teamId}".replace("{teamId}",n),r={},a=new URL(this.client.config.endpoint+o),c={"content-type":"application/json"};return this.client.call("delete",a,c,r)}listMemberships(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,queries:t[0],search:t[1],total:t[2]};const o=n.teamId,r=n.queries,a=n.search,c=n.total;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');const l="/teams/{teamId}/memberships".replace("{teamId}",o),u={};typeof r<"u"&&(u.queries=r),typeof a<"u"&&(u.search=a),typeof c<"u"&&(u.total=c);const d=new URL(this.client.config.endpoint+l),h={};return this.client.call("get",d,h,u)}createMembership(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,roles:t[0],email:t[1],userId:t[2],phone:t[3],url:t[4],name:t[5]};const o=n.teamId,r=n.roles,a=n.email,c=n.userId,l=n.phone,u=n.url,d=n.name;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "roles"');const h="/teams/{teamId}/memberships".replace("{teamId}",o),y={};typeof a<"u"&&(y.email=a),typeof c<"u"&&(y.userId=c),typeof l<"u"&&(y.phone=l),typeof r<"u"&&(y.roles=r),typeof u<"u"&&(y.url=u),typeof d<"u"&&(y.name=d);const w=new URL(this.client.config.endpoint+h),E={"content-type":"application/json"};return this.client.call("post",w,E,y)}getMembership(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,membershipId:t[0]};const o=n.teamId,r=n.membershipId;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "membershipId"');const a="/teams/{teamId}/memberships/{membershipId}".replace("{teamId}",o).replace("{membershipId}",r),c={},l=new URL(this.client.config.endpoint+a),u={};return this.client.call("get",l,u,c)}updateMembership(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,membershipId:t[0],roles:t[1]};const o=n.teamId,r=n.membershipId,a=n.roles;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "membershipId"');if(typeof a>"u")throw new f('Missing required parameter: "roles"');const c="/teams/{teamId}/memberships/{membershipId}".replace("{teamId}",o).replace("{membershipId}",r),l={};typeof a<"u"&&(l.roles=a);const u=new URL(this.client.config.endpoint+c),d={"content-type":"application/json"};return this.client.call("patch",u,d,l)}deleteMembership(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,membershipId:t[0]};const o=n.teamId,r=n.membershipId;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "membershipId"');const a="/teams/{teamId}/memberships/{membershipId}".replace("{teamId}",o).replace("{membershipId}",r),c={},l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("delete",l,u,c)}updateMembershipStatus(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,membershipId:t[0],userId:t[1],secret:t[2]};const o=n.teamId,r=n.membershipId,a=n.userId,c=n.secret;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "membershipId"');if(typeof a>"u")throw new f('Missing required parameter: "userId"');if(typeof c>"u")throw new f('Missing required parameter: "secret"');const l="/teams/{teamId}/memberships/{membershipId}/status".replace("{teamId}",o).replace("{membershipId}",r),u={};typeof a<"u"&&(u.userId=a),typeof c<"u"&&(u.secret=c);const d=new URL(this.client.config.endpoint+l),h={"content-type":"application/json"};return this.client.call("patch",d,h,u)}getPrefs(e){let t;e&&typeof e=="object"&&!Array.isArray(e)?t=e||{}:t={teamId:e};const n=t.teamId;if(typeof n>"u")throw new f('Missing required parameter: "teamId"');const o="/teams/{teamId}/prefs".replace("{teamId}",n),r={},a=new URL(this.client.config.endpoint+o),c={};return this.client.call("get",a,c,r)}updatePrefs(e,...t){let n;e&&typeof e=="object"&&!Array.isArray(e)?n=e||{}:n={teamId:e,prefs:t[0]};const o=n.teamId,r=n.prefs;if(typeof o>"u")throw new f('Missing required parameter: "teamId"');if(typeof r>"u")throw new f('Missing required parameter: "prefs"');const a="/teams/{teamId}/prefs".replace("{teamId}",o),c={};typeof r<"u"&&(c.prefs=r);const l=new URL(this.client.config.endpoint+a),u={"content-type":"application/json"};return this.client.call("put",l,u,c)}}var ts;(function(s){s[s.NORMAL_CLOSURE=1e3]="NORMAL_CLOSURE",s[s.POLICY_VIOLATION=1008]="POLICY_VIOLATION",s[s.UNKNOWN_ERROR=-1]="UNKNOWN_ERROR"})(ts||(ts={}));class U{}U.read=s=>`read("${s}")`;U.write=s=>`write("${s}")`;U.create=s=>`create("${s}")`;U.update=s=>`update("${s}")`;U.delete=s=>`delete("${s}")`;class W{static any(){return"any"}static user(e,t=""){return t===""?`user:${e}`:`user:${e}/${t}`}static users(e=""){return e===""?"users":`users/${e}`}static guests(){return"guests"}static team(e,t=""){return t===""?`team:${e}`:`team:${e}/${t}`}static member(e){return`member:${e}`}static label(e){return`label:${e}`}}var As,Ts;class le{static custom(e){return e}static unique(e=7){const t=Co(le,As,"m",Ts).call(le);let n="";for(let o=0;o<e;o++){const r=Math.floor(Math.random()*16).toString(16);n+=r}return t+n}}As=le,Ts=function(){const e=new Date,t=Math.floor(e.getTime()/1e3),n=e.getMilliseconds();return t.toString(16)+n.toString(16).padStart(5,"0")};var ns;(function(s){s.Equal="equal",s.NotEqual="notEqual",s.GreaterThan="greaterThan",s.GreaterThanEqual="greaterThanEqual",s.LessThan="lessThan",s.LessThanEqual="lessThanEqual",s.Contains="contains",s.IsNull="isNull",s.IsNotNull="isNotNull"})(ns||(ns={}));var ss;(function(s){s.Totp="totp"})(ss||(ss={}));var os;(function(s){s.Email="email",s.Phone="phone",s.Totp="totp",s.Recoverycode="recoverycode"})(os||(os={}));var rs;(function(s){s.Amazon="amazon",s.Apple="apple",s.Auth0="auth0",s.Authentik="authentik",s.Autodesk="autodesk",s.Bitbucket="bitbucket",s.Bitly="bitly",s.Box="box",s.Dailymotion="dailymotion",s.Discord="discord",s.Disqus="disqus",s.Dropbox="dropbox",s.Etsy="etsy",s.Facebook="facebook",s.Figma="figma",s.Github="github",s.Gitlab="gitlab",s.Google="google",s.Linkedin="linkedin",s.Microsoft="microsoft",s.Notion="notion",s.Oidc="oidc",s.Okta="okta",s.Paypal="paypal",s.PaypalSandbox="paypalSandbox",s.Podio="podio",s.Salesforce="salesforce",s.Slack="slack",s.Spotify="spotify",s.Stripe="stripe",s.Tradeshift="tradeshift",s.TradeshiftBox="tradeshiftBox",s.Twitch="twitch",s.Wordpress="wordpress",s.Yahoo="yahoo",s.Yammer="yammer",s.Yandex="yandex",s.Zoho="zoho",s.Zoom="zoom",s.Mock="mock"})(rs||(rs={}));var is;(function(s){s.AvantBrowser="aa",s.AndroidWebViewBeta="an",s.GoogleChrome="ch",s.GoogleChromeIOS="ci",s.GoogleChromeMobile="cm",s.Chromium="cr",s.MozillaFirefox="ff",s.Safari="sf",s.MobileSafari="mf",s.MicrosoftEdge="ps",s.MicrosoftEdgeIOS="oi",s.OperaMini="om",s.Opera="op",s.OperaNext="on"})(is||(is={}));var as;(function(s){s.AmericanExpress="amex",s.Argencard="argencard",s.Cabal="cabal",s.Cencosud="cencosud",s.DinersClub="diners",s.Discover="discover",s.Elo="elo",s.Hipercard="hipercard",s.JCB="jcb",s.Mastercard="mastercard",s.Naranja="naranja",s.TarjetaShopping="targeta-shopping",s.UnionPay="unionpay",s.Visa="visa",s.MIR="mir",s.Maestro="maestro",s.Rupay="rupay"})(as||(as={}));var cs;(function(s){s.Afghanistan="af",s.Angola="ao",s.Albania="al",s.Andorra="ad",s.UnitedArabEmirates="ae",s.Argentina="ar",s.Armenia="am",s.AntiguaAndBarbuda="ag",s.Australia="au",s.Austria="at",s.Azerbaijan="az",s.Burundi="bi",s.Belgium="be",s.Benin="bj",s.BurkinaFaso="bf",s.Bangladesh="bd",s.Bulgaria="bg",s.Bahrain="bh",s.Bahamas="bs",s.BosniaAndHerzegovina="ba",s.Belarus="by",s.Belize="bz",s.Bolivia="bo",s.Brazil="br",s.Barbados="bb",s.BruneiDarussalam="bn",s.Bhutan="bt",s.Botswana="bw",s.CentralAfricanRepublic="cf",s.Canada="ca",s.Switzerland="ch",s.Chile="cl",s.China="cn",s.CoteDIvoire="ci",s.Cameroon="cm",s.DemocraticRepublicOfTheCongo="cd",s.RepublicOfTheCongo="cg",s.Colombia="co",s.Comoros="km",s.CapeVerde="cv",s.CostaRica="cr",s.Cuba="cu",s.Cyprus="cy",s.CzechRepublic="cz",s.Germany="de",s.Djibouti="dj",s.Dominica="dm",s.Denmark="dk",s.DominicanRepublic="do",s.Algeria="dz",s.Ecuador="ec",s.Egypt="eg",s.Eritrea="er",s.Spain="es",s.Estonia="ee",s.Ethiopia="et",s.Finland="fi",s.Fiji="fj",s.France="fr",s.MicronesiaFederatedStatesOf="fm",s.Gabon="ga",s.UnitedKingdom="gb",s.Georgia="ge",s.Ghana="gh",s.Guinea="gn",s.Gambia="gm",s.GuineaBissau="gw",s.EquatorialGuinea="gq",s.Greece="gr",s.Grenada="gd",s.Guatemala="gt",s.Guyana="gy",s.Honduras="hn",s.Croatia="hr",s.Haiti="ht",s.Hungary="hu",s.Indonesia="id",s.India="in",s.Ireland="ie",s.IranIslamicRepublicOf="ir",s.Iraq="iq",s.Iceland="is",s.Israel="il",s.Italy="it",s.Jamaica="jm",s.Jordan="jo",s.Japan="jp",s.Kazakhstan="kz",s.Kenya="ke",s.Kyrgyzstan="kg",s.Cambodia="kh",s.Kiribati="ki",s.SaintKittsAndNevis="kn",s.SouthKorea="kr",s.Kuwait="kw",s.LaoPeopleSDemocraticRepublic="la",s.Lebanon="lb",s.Liberia="lr",s.Libya="ly",s.SaintLucia="lc",s.Liechtenstein="li",s.SriLanka="lk",s.Lesotho="ls",s.Lithuania="lt",s.Luxembourg="lu",s.Latvia="lv",s.Morocco="ma",s.Monaco="mc",s.Moldova="md",s.Madagascar="mg",s.Maldives="mv",s.Mexico="mx",s.MarshallIslands="mh",s.NorthMacedonia="mk",s.Mali="ml",s.Malta="mt",s.Myanmar="mm",s.Montenegro="me",s.Mongolia="mn",s.Mozambique="mz",s.Mauritania="mr",s.Mauritius="mu",s.Malawi="mw",s.Malaysia="my",s.Namibia="na",s.Niger="ne",s.Nigeria="ng",s.Nicaragua="ni",s.Netherlands="nl",s.Norway="no",s.Nepal="np",s.Nauru="nr",s.NewZealand="nz",s.Oman="om",s.Pakistan="pk",s.Panama="pa",s.Peru="pe",s.Philippines="ph",s.Palau="pw",s.PapuaNewGuinea="pg",s.Poland="pl",s.FrenchPolynesia="pf",s.NorthKorea="kp",s.Portugal="pt",s.Paraguay="py",s.Qatar="qa",s.Romania="ro",s.Russia="ru",s.Rwanda="rw",s.SaudiArabia="sa",s.Sudan="sd",s.Senegal="sn",s.Singapore="sg",s.SolomonIslands="sb",s.SierraLeone="sl",s.ElSalvador="sv",s.SanMarino="sm",s.Somalia="so",s.Serbia="rs",s.SouthSudan="ss",s.SaoTomeAndPrincipe="st",s.Suriname="sr",s.Slovakia="sk",s.Slovenia="si",s.Sweden="se",s.Eswatini="sz",s.Seychelles="sc",s.Syria="sy",s.Chad="td",s.Togo="tg",s.Thailand="th",s.Tajikistan="tj",s.Turkmenistan="tm",s.TimorLeste="tl",s.Tonga="to",s.TrinidadAndTobago="tt",s.Tunisia="tn",s.Turkey="tr",s.Tuvalu="tv",s.Tanzania="tz",s.Uganda="ug",s.Ukraine="ua",s.Uruguay="uy",s.UnitedStates="us",s.Uzbekistan="uz",s.VaticanCity="va",s.SaintVincentAndTheGrenadines="vc",s.Venezuela="ve",s.Vietnam="vn",s.Vanuatu="vu",s.Samoa="ws",s.Yemen="ye",s.SouthAfrica="za",s.Zambia="zm",s.Zimbabwe="zw"})(cs||(cs={}));var ut;(function(s){s.GET="GET",s.POST="POST",s.PUT="PUT",s.PATCH="PATCH",s.DELETE="DELETE",s.OPTIONS="OPTIONS",s.HEAD="HEAD"})(ut||(ut={}));var ls;(function(s){s.Center="center",s.Topleft="top-left",s.Top="top",s.Topright="top-right",s.Left="left",s.Right="right",s.Bottomleft="bottom-left",s.Bottom="bottom",s.Bottomright="bottom-right"})(ls||(ls={}));var us;(function(s){s.Jpg="jpg",s.Jpeg="jpeg",s.Png="png",s.Webp="webp",s.Heic="heic",s.Avif="avif",s.Gif="gif"})(us||(us={}));var ds;(function(s){s.Http="http",s.Schedule="schedule",s.Event="event"})(ds||(ds={}));var ps;(function(s){s.Waiting="waiting",s.Processing="processing",s.Completed="completed",s.Failed="failed",s.Scheduled="scheduled"})(ps||(ps={}));const ae={endpoint:"https://aw.oupla.net/v1",projectId:"696b7acb0037bde79e3f",databaseId:"689d15b10003a5a13636",functions:{cmsAuth:"68976500002eb5c6ee4f",accessRequest:"689cdea5001a4d74549d",batchUpdate:"68f00487000c624533a3",usersTeamsManager:"692cb2cd000cbb24549c",enkaData:"68f00487000c624533a3"},collections:{events:"main",ingredients:"ingredients",main:"main",purchases:"purchases",products:"products",kteams:"kteams",locks:"locks",user_notifications:"user_notifications",materiel_loan:"materiel_loan",teamdocs:"teamdocs"}};let at=null;async function b(){if(at)return at;console.log("[appwrite] Initialisation des instances Appwrite...");const s=new we().setEndpoint(ae.endpoint).setProject(ae.projectId),e=new _o(s),t=new No(s),n=new jo(s),o=new qo(s),r=new ko(s);return at={client:s,account:e,databases:t,tables:n,functions:o,teams:r,config:ae},console.log("[appwrite] Instances initialisées avec succès"),at}function Uo(){console.log("[appwrite] Cache réinitialisé"),at=null}function ot(){return{APPWRITE_ENDPOINT:ae.endpoint,APPWRITE_PROJECT_ID:ae.projectId,APPWRITE_DATABASE_ID:ae.databaseId,APPWRITE_FUNCTION_ID:ae.functions.batchUpdate,ACCESS_REQUEST_FUNCTION_ID:ae.functions.accessRequest,MANAGE_RECIPE_FUNCTION_ID:ae.functions.enkaData,APPWRITE_CONFIG:ae}}function Te(){return ae.databaseId}function Be(s){return ae.collections[s]}function jn(s){return ae.functions[s]}function Ps(s,e){const{operationName:t,maxAutoRetries:n=1,autoRetryDelay:o=1e3}=e;let r=1;return new Promise((a,c)=>{const l=async()=>{try{console.log(`[RetryUtils] ${t} - Tentative ${r}/${n+1}`);const u=await s();console.log(`[RetryUtils] ${t} - Succès`),e.onSuccess?.(u),a(u)}catch(u){if(console.error(`[RetryUtils] Erreur ${t} (Tentative ${r}):`,u),u instanceof Error&&u.message,r<=n){r++,console.log(`[RetryUtils] Nouvelle tentative dans ${o/1e3}s...`),setTimeout(()=>l(),o);return}console.error(`[RetryUtils] ${t} - Échec après ${r} tentatives`),e.onError?.(u),c(u)}};l()})}async function ye(s,e={}){const{maxAttempts:t=3,timeout:n=1e4,context:o="Operation",successMessage:r,errorMessage:a,retryDelay:c=1e3,silent:l=!1}=e;let u=null;for(let d=1;d<=t;d++)try{console.log(`[${o}] Tentative ${d}/${t}`);const h=await Promise.race([s(),Lo(n)]);return d>1&&console.log(`[${o}] ✓ Succès après ${d} tentatives`),r&&!l&&Se.success(r),h}catch(h){if(u=h instanceof Error?h:new Error(String(h)),console.error(`[${o}] ✗ Tentative ${d}/${t} échouée:`,u.message),d===t)throw console.error(`[${o}] ✗ Échec après ${t} tentatives`),a&&!l&&Se.error(a),u;const y=c*d;console.log(`[${o}] Nouvelle tentative dans ${y}ms...`),await xo(y)}throw u||new Error(`${o}: Échec inconnu`)}function Lo(s){return new Promise((e,t)=>{setTimeout(()=>{t(new Error(`Timeout après ${s}ms`))},s)})}function xo(s){return new Promise(e=>setTimeout(e,s))}function Jt(s,e={}){const{fallback:t=null,context:n="JSON.parse"}=e;try{return JSON.parse(s)}catch(o){return console.error(`[${n}] ✗ JSON invalide:`,o instanceof Error?o.message:o),t}}function kn(s,e={}){const{context:t="JSON.parseArray",itemFallback:n}=e;return!s||!Array.isArray(s)?(console.warn(`[${t}] Tableau vide ou invalide`),[]):s.map((o,r)=>{const a=Jt(o,{context:`${t}[${r}]`,fallback:void 0});return a===void 0&&n?n(o,r):a}).filter(o=>o!==null)}const{APPWRITE_CONFIG:ve}=ot(),Ve="main";async function hs(s,e=null){return ye(async()=>{const{tables:t}=await b(),n=[g.orderDesc("dateStart")];return e&&n.push(g.greaterThanEqual("dateEnd",e)),{events:(await t.listRows({databaseId:ve.databaseId,tableId:Ve,queries:n})).rows}},{context:"AppwriteEvents.listEvents",timeout:2e4,errorMessage:"Erreur lors du chargement des événements"})}async function Bo(s){try{return await ye(async()=>{const{tables:e}=await b();return await e.getRow({databaseId:ve.databaseId,tableId:Ve,rowId:s})},{context:"AppwriteEvents.getEvent",timeout:1e4,errorMessage:"Erreur lors du chargement de l'événement"})}catch(e){if(e.code===404)return null;throw e}}async function Ho(s,e){return ye(async()=>{const{tables:t}=await b(),n=le.unique(),o=await t.createRow({databaseId:ve.databaseId,tableId:Ve,rowId:n,data:{name:s.name,dateStart:s.dateStart,dateEnd:s.dateEnd,allDates:s.allDates,meals:s.meals?s.meals.map(a=>JSON.stringify(a)):[],createdBy:e,teams:s.teams??[],contributors:s.contributors?s.contributors.map(a=>JSON.stringify(a)):[],todos:s.todos?s.todos.map(a=>JSON.stringify(a)):[]}});console.log(`[appwrite-events] Event created: ${n}`);const{functions:r}=await b();return await r.createExecution({functionId:ve.functions.usersTeamsManager,body:JSON.stringify({action:"add-label-to-user",mainId:n,userId:e}),async:!1}),console.log(`[appwrite-events] Label ${n} attribué au créateur ${e}`),o},{context:"AppwriteEvents.createEvent",timeout:15e3,successMessage:"Événement créé avec succès",errorMessage:"Erreur lors de la création de l'événement"})}async function zo(s,e,t=[],n=!0){return ye(async()=>{const{functions:o}=await b(),r={name:s.name,description:s.description||"",dateStart:s.dateStart,dateEnd:s.dateEnd,allDates:s.allDates,meals:s.meals?s.meals.map(d=>JSON.stringify(d)):[],createdBy:e,teams:s.teams||[],teamsId:s.teamsId||[],contributors:s.contributors?s.contributors.map(d=>JSON.stringify(d)):[],todos:s.todos?s.todos.map(d=>JSON.stringify(d)):[],status:s.status||"proposition"};console.log(`[appwrite-events] Création événement avec ${t.length} team(s)`);const a=await o.createExecution({functionId:ve.functions.usersTeamsManager,body:JSON.stringify({action:"create-event-with-teams",eventData:r,creatorId:e,teamIds:t,sendEmailToExistingMembers:n}),async:!1}),c=JSON.parse(a.responseBody);if(!c.success)throw new Error(c.error||"Erreur lors de la création");console.log(`[appwrite-events] Événement créé avec teams: ${c.eventId}`);const{tables:l}=await b();return await l.getRow({databaseId:ve.databaseId,tableId:Ve,rowId:c.eventId})},{context:"AppwriteEvents.createEventWithTeams",timeout:3e4,successMessage:"Événement créé avec succès",errorMessage:"Erreur lors de la création de l'événement"})}async function fs(s,e){return ye(async()=>{const{tables:t}=await b(),n={...e};e.meals&&(n.meals=e.meals.map(r=>JSON.stringify(r))),e.contributors&&(n.contributors=Array.isArray(e.contributors)?e.contributors.map(r=>JSON.stringify(r)):[]),e.todos&&(n.todos=e.todos.map(r=>JSON.stringify(r))),e.allDates&&(n.allDates=e.allDates);const o=await t.updateRow({databaseId:ve.databaseId,tableId:Ve,rowId:s,data:n});return console.log(`[appwrite-events] Event updated: ${s}`),o},{context:"AppwriteEvents.updateEvent",timeout:1e4,successMessage:"Événement mis à jour",errorMessage:"Erreur lors de la mise à jour"})}async function Wo(s){return ye(async()=>{const{tables:e,functions:t}=await b();await e.deleteRow({databaseId:ve.databaseId,tableId:Ve,rowId:s}),console.log(`[appwrite-events] Event deleted: ${s}`),await t.createExecution({functionId:ve.functions.usersTeamsManager,body:JSON.stringify({action:"delete-event-label",mainId:s}),async:!0}),console.log(`[appwrite-events] Label deletion initiated for event: ${s}`)},{context:"AppwriteEvents.deleteEvent",timeout:1e4,successMessage:"Événement supprimé",errorMessage:"Erreur lors de la suppression"})}async function Go(){const{teams:s}=await b();return await s.list()}async function Oo(s){const{teams:e}=await b();return await e.get({teamId:s})}async function Qo(s){const{teams:e}=await b();return await e.create({teamId:le.unique(),name:s})}async function Jo(s,e){const{teams:t}=await b();return await t.updateName({teamId:s,name:e})}async function Vo(s){const{teams:e}=await b();await e.delete({teamId:s})}async function Ko(s){const{teams:e}=await b();return await e.listMemberships({teamId:s})}async function Yo(s,e){const{teams:t}=await b();await t.deleteMembership({teamId:s,membershipId:e})}async function Xo(s,e,t){const{functions:n}=await b(),o=jn("usersTeamsManager"),r={action:"native-invite",teamId:s,emails:e,message:t},a=await n.createExecution({functionId:o,body:JSON.stringify(r)});if(a.status!=="completed")throw new Error(`Erreur lors de l'invitation : ${a.errors}`);return JSON.parse(a.responseBody)}async function ms(s,e){const{teams:t}=await b();return await t.updatePrefs({teamId:s,prefs:e})}var he,ze,Ie,pn,$s;class Zo{constructor(){I(this,pn);I(this,he,[]);I(this,ze,null);I(this,Ie,!1)}register(e,t){i(this,Ie)&&console.warn("[RealtimeManager] Enregistrement après initialisation. Utilisez registerDynamic() pour les inscriptions dynamiques."),i(this,he).push({channels:e,callback:t}),console.log("[RealtimeManager] Channels enregistrés:",e)}registerDynamic(e,t){return i(this,he).push({channels:e,callback:t}),console.log("[RealtimeManager] Channels dynamiques enregistrés:",e),i(this,Ie)&&S(this,pn,$s).call(this,e,t),()=>{const n=i(this,he).findIndex(o=>o.channels===e&&o.callback===t);n!==-1&&(i(this,he).splice(n,1),console.log("[RealtimeManager] Channels dynamiques désenregistrés:",e))}}async initialize(){if(i(this,Ie))return;const e=[...new Set(i(this,he).flatMap(t=>t.channels))];if(e.length===0){console.log("[RealtimeManager] Aucun channel à souscrire."),j(this,Ie,!0);return}try{console.log(`[RealtimeManager] Initialisation de la connexion unique avec ${e.length} channels...`);const{client:t}=await b();j(this,ze,t.subscribe(e,n=>{for(const o of i(this,he))n.channels.some(a=>o.channels.includes(a))&&o.callback(n)})),j(this,Ie,!0),console.log("[RealtimeManager] ✅ Connexion Realtime établie.")}catch(t){throw console.error("[RealtimeManager] Erreur lors de l'initialisation:",t),t}}destroy(){i(this,ze)&&(i(this,ze).call(this),j(this,ze,null)),j(this,he,[]),j(this,Ie,!1),console.log("[RealtimeManager] Connexion Realtime fermée.")}}he=new WeakMap,ze=new WeakMap,Ie=new WeakMap,pn=new WeakSet,$s=async function(e,t){try{console.log(`[RealtimeManager] Ajout de ${e.length} channels à la connexion existante...`);const{client:n}=await b();n.subscribe(e,o=>{t(o)}),console.log("[RealtimeManager] ✅ Channels dynamiques ajoutés:",e)}catch(n){console.error("[RealtimeManager] Erreur lors de l'ajout de channels dynamiques:",n)}};const Vt=new Zo;var F,Pe,We,be,Ze,dt,Le,rn,Ds;class Fo{constructor(){I(this,Le);I(this,F,new st);I(this,Pe,N(!1));I(this,We,N(null));I(this,be,N(!1));I(this,Ze,!1);I(this,dt,z(()=>Array.from(i(this,F).values())))}get loading(){return p(i(this,Pe))}get error(){return p(i(this,We))}get isInitialized(){return p(i(this,be))}get count(){return i(this,F).size}get teams(){return p(i(this,dt))}isUserInAnyTeam(e){return Array.from(i(this,F).values()).some(t=>t.members?.some(n=>n.id===e))}get myTeams(){return k.userId?p(i(this,dt)):[]}async loadCache(){if(!p(i(this,be))){if(!k.userId){m(i(this,be),!0);return}m(i(this,be),!0),console.log("[NativeTeamsStore] Cache chargé : 0 équipes (pas de cache)")}}async syncFromRemote(){m(i(this,Pe),!0),m(i(this,We),null);try{if(!k.userId)return;await S(this,Le,rn).call(this),console.log(`[NativeTeamsStore] Sync terminé : ${i(this,F).size} équipes`)}catch(e){throw m(i(this,We),e instanceof Error?e.message:"Erreur de synchronisation",!0),console.error("[NativeTeamsStore] SyncFromRemote error:",e),e}finally{m(i(this,Pe),!1)}}async setupRealtime(){if(k.userId){if(i(this,Ze)){console.log("[NativeTeamsStore] Realtime déjà configuré");return}try{await S(this,Le,Ds).call(this),j(this,Ze,!0),console.log("[NativeTeamsStore] Realtime configuré")}catch(e){throw m(i(this,We),e instanceof Error?e.message:"Erreur de configuration realtime",!0),console.error("[NativeTeamsStore] SetupRealtime error:",e),e}}}async initialize(){await this.loadCache(),await this.syncFromRemote(),await this.setupRealtime()}async hardReset(){console.log("[NativeTeamsStore] Hard reset..."),i(this,F).clear(),m(i(this,be),!1),await this.initialize(),console.log("[NativeTeamsStore] Hard reset terminé")}getTeamById(e){return i(this,F).get(e)}getTeamMemberNames(e){const t=i(this,F).get(e);return!t||!t.members?[]:t.members.map(n=>n.name?n.name:n.userEmail?n.userEmail.split("@")[0]:"Inconnu").filter(Boolean)}async fetchTeam(e){try{const t=await Oo(e),n=await Ko(e),o={$id:t.$id,name:t.name,total:t.total,$createdAt:t.$createdAt,$updatedAt:t.$updatedAt,prefs:t.prefs,members:n.memberships.map(r=>({$id:r.$id,id:r.userId,name:r.userName,userEmail:r.userEmail,roles:r.roles,joinedAt:r.joined,confirmed:r.confirm}))};return i(this,F).set(e,o),o}catch(t){return console.error(`[NativeTeamsStore] Error fetching team ${e}:`,t),null}}async createTeam(e,t){const n=await Qo(e);t&&Object.keys(t).length>0&&await ms(n.$id,t);const o=await this.fetchTeam(n.$id);if(!o)throw new Error("Erreur après création d'équipe");return o}async updateTeam(e,t,n){t&&await Jo(e,t),n&&Object.keys(n).length>0&&await ms(e,n),await this.fetchTeam(e)}async deleteTeam(e){await Vo(e),i(this,F).delete(e)}async inviteTeamMember(e,t,n){await Xo(e,t,n),await this.fetchTeam(e)}async removeMember(e,t){await Yo(e,t),await this.fetchTeam(e)}async reload(){m(i(this,Pe),!0);try{i(this,F).clear(),await S(this,Le,rn).call(this)}finally{m(i(this,Pe),!1)}}destroy(){i(this,F).clear(),m(i(this,be),!1),j(this,Ze,!1)}}F=new WeakMap,Pe=new WeakMap,We=new WeakMap,be=new WeakMap,Ze=new WeakMap,dt=new WeakMap,Le=new WeakSet,rn=async function(){const e=await Go();for(const t of e.teams)await this.fetchTeam(t.$id)},Ds=async function(){Vt.register(["teams","memberships"],async e=>{console.log("[NativeTeamsStore] ⚡️ Realtime RECEIVED:",e.events),await S(this,Le,rn).call(this)})};const Re=new Fo;var pt,ht,ft;class er{constructor(){C(this,"routes",[]);I(this,pt,N(""));I(this,ht,N(ce({})));I(this,ft,N(ce({})));C(this,"currentRouteMatch",null);C(this,"isNavigating",!1);C(this,"dynamicGuards",new Map);C(this,"componentCache",new Map);this.currentPath=this.getHashPath(),this.updateQueryParams(),window.addEventListener("hashchange",()=>{const e=this.getHashPath();this.handleHashChange(e)})}get currentPath(){return p(i(this,pt))}set currentPath(e){m(i(this,pt),e,!0)}get currentParams(){return p(i(this,ht))}set currentParams(e){m(i(this,ht),e,!0)}get currentQuery(){return p(i(this,ft))}set currentQuery(e){m(i(this,ft),e,!0)}addRoute(e,t,n){this.routes.push({path:e,component:t,guards:n})}registerRouteGuard(e,t){return this.dynamicGuards.set(e,t),()=>{this.dynamicGuards.delete(e)}}async handleHashChange(e){if(this.isNavigating)return;this.updateQueryParams();const t={path:this.currentPath,params:this.currentParams,query:this.currentQuery},n={path:e,params:{},query:this.currentQuery},o=this.dynamicGuards.get(t.path);if(o?.beforeLeave)try{if(!await o.beforeLeave(t,n)){console.log("[Router] Navigation annulée par beforeLeave (guard dynamique)"),window.location.hash=t.path;return}}catch(a){console.error("[Router] Erreur dans beforeLeave (guard dynamique):",a)}if(this.currentRouteMatch?.guards?.beforeLeave)try{if(!await this.currentRouteMatch.guards.beforeLeave(t,n)){console.log("[Router] Navigation annulée par beforeLeave (guard statique)"),window.location.hash=t.path;return}}catch(a){console.error("[Router] Erreur dans beforeLeave (guard statique):",a)}const r=await this.findRouteMatch(e);if(!r){this.currentPath=e,this.currentParams={},this.currentRouteMatch=null;return}if(n.params=r.params,r.guards?.beforeEnter)try{if(!await r.guards.beforeEnter(n,t)){console.log("[Router] Navigation annulée par beforeEnter"),window.location.hash=t.path;return}}catch(a){console.error("[Router] Erreur dans beforeEnter:",a)}this.currentPath=e,this.currentParams=r.params,this.currentRouteMatch=r}async navigate(e,t){if(!this.isNavigating){this.isNavigating=!0;try{const n={path:this.currentPath,params:this.currentParams,query:this.currentQuery},o=await this.findRouteMatch(e),r={path:e,params:o?.params||{},query:t||{}};if(this.currentRouteMatch?.guards?.beforeLeave&&!await this.currentRouteMatch.guards.beforeLeave(n,r)){console.log("[Router] Navigation annulée par beforeLeave");return}if(o?.guards?.beforeEnter&&!await o.guards.beforeEnter(r,n)){console.log("[Router] Navigation annulée par beforeEnter");return}const a=t?"?"+new URLSearchParams(t).toString():"",c="#"+(e.startsWith("/")?e:"/"+e)+a;window.location.hash=c}finally{this.isNavigating=!1}}}async findRouteMatch(e){for(const t of this.routes){const n=this.matchRoute(t.path,e);if(n)return{component:await this.resolveComponent(t.path.toString(),t.component),params:n.params,query:this.currentQuery,guards:t.guards}}return null}async resolveComponent(e,t){if(typeof t!="function"||t.length>0)return t;if(this.componentCache.has(e))return this.componentCache.get(e);try{const o=(await t()).default;return this.componentCache.set(e,o),o}catch(n){throw console.error(`[Router] Erreur lors du chargement du composant pour ${e}:`,n),n}}async match(){const e=await this.findRouteMatch(this.currentPath);return e&&(this.currentParams=e.params,this.currentRouteMatch=e),e}matchRoute(e,t){if(e instanceof RegExp){const c=t.match(e);return c?{params:c.groups||{}}:null}const n=[],o=e.replace(/:([^/]+)/g,(c,l)=>(n.push(l),"([^/]+)")),r=new RegExp(`^${o}$`),a=t.match(r);if(a){const c={};return n.forEach((l,u)=>{c[l]=a[u+1]}),{params:c}}return null}getHashPath(){return window.location.hash.slice(1).split("?")[0]||"/"}updateQueryParams(){const t=window.location.hash.slice(1).split("?")[1],n={};t&&new URLSearchParams(t).forEach((r,a)=>{n[a]=r}),this.currentQuery=n}get path(){return this.currentPath}get params(){return this.currentParams}get query(){return this.currentQuery}async preload(e){const t=this.routes.find(n=>typeof n.path=="string"?n.path===e:!1);t&&(await this.resolveComponent(t.path.toString(),t.component),console.log(`[Router] Composant préchargé: ${e}`))}}pt=new WeakMap,ht=new WeakMap,ft=new WeakMap;const Xe=new er;function ei(s,e){Xe.navigate(s,e)}function ti(s){return Xe.query[s]}function ni(s){return Xe.preload(s)}var B,se,$e,De,Ge,mt,yt,gt,wt,It;class tr{constructor(){C(this,"isMobileQuery",new Xn("max-width: 768px"));C(this,"isDesktopQuery",new Xn("min-width: 1024px"));I(this,B,N(null));I(this,se,N(ce([])));I(this,$e,N(!1));I(this,De,N(null));I(this,Ge,N(!1));I(this,mt,z(()=>{const e=Xe.path,t=Xe.params.mainid||Xe.params.mainId;return e.startsWith("/products/")&&t?t:null}));I(this,yt,N(ce({isOpen:!1,conflicts:[]})));I(this,gt,N(ce({isOpen:!1})));I(this,wt,N(ce({isRunning:!1,name:"",progress:0})));I(this,It,N(ce({isOpen:!1})))}get user(){return p(i(this,B))}get userId(){return p(i(this,B))?.$id??null}get userEmail(){return p(i(this,B))?.email??null}get userTeams(){return p(i(this,se))}get isAuthenticated(){return p(i(this,B))!==null}get authLoading(){return p(i(this,$e))}get authError(){return p(i(this,De))}get authInitialized(){return p(i(this,Ge))}async initializeAuth(){if(p(i(this,Ge))){console.log("[GlobalState] Authentification déjà initialisée");return}console.log("[GlobalState] Initialisation de l'authentification..."),m(i(this,$e),!0),m(i(this,De),null);try{const{account:e}=await b();m(i(this,B),await e.get(),!0),localStorage.setItem("appwrite-user-name",p(i(this,B)).name),localStorage.setItem("appwrite-user-email",p(i(this,B)).email),localStorage.setItem("appwrite-user-id",p(i(this,B)).$id),await Re.initialize(),m(i(this,se),Re.myTeams.map(t=>t.$id),!0),console.log(`[GlobalState] Authentifié: ${p(i(this,B)).name} (${p(i(this,se)).length} équipes)`)}catch(e){m(i(this,B),null),m(i(this,se),[],!0),m(i(this,De),e instanceof Error?e.message:"Erreur d'authentification",!0),console.log("[GlobalState] Utilisateur non connecté")}finally{m(i(this,$e),!1),m(i(this,Ge),!0)}}async refreshAuthAfterLogin(){console.log("[GlobalState] Réinitialisation après login..."),m(i(this,$e),!0),m(i(this,De),null);try{const{account:e}=await b();m(i(this,B),await e.get(),!0),localStorage.setItem("appwrite-user-name",p(i(this,B)).name),localStorage.setItem("appwrite-user-email",p(i(this,B)).email),localStorage.setItem("appwrite-user-id",p(i(this,B)).$id),await Re.initialize(),m(i(this,se),Re.myTeams.map(t=>t.$id),!0),console.log(`[GlobalState] Réinitialisé après login: ${p(i(this,B)).name} (${p(i(this,se)).length} équipes)`)}catch(e){console.error("[GlobalState] Erreur lors de la réinitialisation:",e),m(i(this,De),e instanceof Error?e.message:"Erreur de réinitialisation",!0)}finally{m(i(this,$e),!1)}}async logout(){try{const{account:e}=await b();await e.deleteSession({sessionId:"current"}),Uo(),localStorage.removeItem("appwrite-user-name"),localStorage.removeItem("appwrite-user-email"),localStorage.removeItem("appwrite-user-id"),m(i(this,B),null),m(i(this,se),[],!0),m(i(this,Ge),!1),console.log("[GlobalState] Déconnexion réussie")}catch(e){throw console.error("[GlobalState] Erreur lors de la déconnexion:",e),e}}async refreshTeams(){if(!p(i(this,B))){console.warn("[GlobalState] Impossible de rafraîchir les équipes: utilisateur non connecté");return}try{await Re.syncFromRemote();const e=Re.myTeams.map(t=>t.$id);(e.length>0||p(i(this,se)).length===0)&&(m(i(this,se),e,!0),console.log(`[GlobalState] Équipes rafraîchies: ${p(i(this,se)).length}`))}catch(e){console.error("[GlobalState] Erreur lors du rafraîchissement des équipes:",e)}}isTeamOwner(e){if(!p(i(this,B)))return!1;const t=Re.myTeams.find(o=>o.$id===e);return t?t.members.find(o=>o.id===p(i(this,B)).$id)?.roles?.includes("owner")??!1:!1}hasTeamRole(e,t){if(!p(i(this,B)))return!1;const n=Re.myTeams.find(r=>r.$id===e);return n?n.members.find(r=>r.id===p(i(this,B)).$id)?.roles?.includes(t)??!1:!1}get currentMainId(){return p(i(this,mt))}setCurrentMainId(e){m(i(this,mt),e),console.log(`[GlobalState] currentMainId mis à jour: ${e}`)}get isMobile(){return this.isMobileQuery.current}get isDesktop(){return this.isDesktopQuery.current}get userName(){return p(i(this,B))?.name||localStorage.getItem("appwrite-user-name")||""}get toasts(){return Se.toasts}get toast(){return Se}get modalOverride(){return p(i(this,yt))}set modalOverride(e){m(i(this,yt),e,!0)}get modal(){return p(i(this,gt))}set modal(e){m(i(this,gt),e,!0)}get backgroundOperation(){return p(i(this,wt))}set backgroundOperation(e){m(i(this,wt),e,!0)}get authModal(){return p(i(this,It))}set authModal(e){m(i(this,It),e,!0)}}B=new WeakMap,se=new WeakMap,$e=new WeakMap,De=new WeakMap,Ge=new WeakMap,mt=new WeakMap,yt=new WeakMap,gt=new WeakMap,wt=new WeakMap,It=new WeakMap;const k=new tr;var bt,Et;class nr{constructor(){I(this,bt,N("survolez des élément pour obtenir de l'aide"));I(this,Et,N(!0));C(this,"reset",()=>{this.msg="survolez des élément pour obtenir de l'aide"});C(this,"toggle",()=>{this.isExpanded=!this.isExpanded});C(this,"expand",()=>{this.isExpanded=!0});C(this,"collapse",()=>{this.isExpanded=!1})}get msg(){return p(i(this,bt))}set msg(e){m(i(this,bt),e,!0)}get isExpanded(){return p(i(this,Et))}set isExpanded(e){m(i(this,Et),e,!0)}get help(){return this.msg}set help(e){this.msg=e}}bt=new WeakMap,Et=new WeakMap;const si=new nr;function sr(s){return kn(s,{context:"parseEventMeals",itemFallback:(e,t)=>(console.warn(`[parseEventMeals] Meal ${t} invalide, utilisation d'un fallback`,e),{id:`unknown-${t}`,name:"Repas inconnu",date:new Date().toISOString(),guests:1,recipes:[]})})}function or(s){return kn(s,{context:"parseEventContributors",itemFallback:(e,t)=>(console.warn(`[parseEventContributors] Contributor ${t} invalide, utilisation d'un fallback`,e),{id:typeof e=="string"?e:`unknown-${t}`,status:"accepted",invitedAt:new Date().toISOString()})})}function rr(s){return kn(s,{context:"parseEventTodos",itemFallback:(e,t)=>(console.warn(`[parseEventTodos] Todo ${t} invalide, utilisation d'un fallback`,e),{id:`unknown-${t}`,taskName:"Tâche invalide",taskDescription:null,dueDate:null,priority:null,status:null,taskOn:null,requiredPeopleNb:1,assignedTo:null})})}class ir{constructor(){C(this,"dbName","events-cache");C(this,"db",null);C(this,"version",2);C(this,"EVENTS_STORE","events");C(this,"METADATA_STORE","metadata");C(this,"POSTER_CONFIGS_STORE","poster-configs");C(this,"LAST_SYNC_KEY","lastSync")}async open(){if(this.db)return;const e=()=>new Promise((a,c)=>{const l=indexedDB.open(this.dbName,this.version);l.onerror=()=>c(l.error),l.onsuccess=()=>a(l.result),l.onupgradeneeded=u=>{const d=u.target.result;d.objectStoreNames.contains(this.EVENTS_STORE)||(d.createObjectStore(this.EVENTS_STORE,{keyPath:"$id"}),console.log("[EventsIDBCache] Object store 'events' créé")),d.objectStoreNames.contains(this.METADATA_STORE)||(d.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[EventsIDBCache] Object store 'metadata' créé")),d.objectStoreNames.contains(this.POSTER_CONFIGS_STORE)||(d.createObjectStore(this.POSTER_CONFIGS_STORE,{keyPath:"eventId"}),console.log("[EventsIDBCache] Object store 'poster-configs' créé"))}});let t=await e();const n=t.objectStoreNames.contains(this.EVENTS_STORE),o=t.objectStoreNames.contains(this.METADATA_STORE),r=t.objectStoreNames.contains(this.POSTER_CONFIGS_STORE);(!n||!o||!r)&&(console.warn(`[EventsIDBCache] Base incomplète détectée (events=${n}, metadata=${o}, posters=${r}), suppression et recréation...`),t.close(),await new Promise((a,c)=>{const l=indexedDB.deleteDatabase(this.dbName);l.onsuccess=()=>a(),l.onerror=()=>c(l.error),l.onblocked=()=>{console.warn("[EventsIDBCache] Suppression bloquée, réessai...")}}),t=await e()),this.db=t,console.log(`[EventsIDBCache] Base ouverte: ${this.dbName}`)}async loadEvents(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.EVENTS_STORE,"readonly").objectStore(this.EVENTS_STORE).getAll();r.onsuccess=()=>{const a=new Map;r.result.forEach(c=>{a.set(c.$id,c)}),console.log(`[EventsIDBCache] ${a.size} événements chargés`),e(a)},r.onerror=()=>t(r.error)})}async saveEvents(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.EVENTS_STORE,"readwrite"),r=o.objectStore(this.EVENTS_STORE);r.clear(),e.forEach(a=>{r.put(a)}),o.oncomplete=()=>{console.log(`[EventsIDBCache] ${e.size} événements sauvegardés`),t()},o.onerror=()=>n(o.error)})}async saveEvent(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.EVENTS_STORE,"readwrite").objectStore(this.EVENTS_STORE).put(e);a.onsuccess=()=>{console.log(`[EventsIDBCache] Événement ${e.$id} sauvegardé`),t()},a.onerror=()=>n(a.error)})}async deleteEvent(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.EVENTS_STORE,"readwrite").objectStore(this.EVENTS_STORE).delete(e);a.onsuccess=()=>{console.log(`[EventsIDBCache] Événement ${e} supprimé`),t()},a.onerror=()=>n(a.error)})}async loadPosterConfig(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const r=this.db.transaction(this.POSTER_CONFIGS_STORE,"readwrite").objectStore(this.POSTER_CONFIGS_STORE),a=r.get(e);a.onsuccess=()=>{const c=a.result;if(!c){t(null);return}if(c.config&&!c.current){console.log(`[EventsIDBCache] Migration config affiche V1 -> V2 pour ${e}`);const l={current:c.config,versions:[]};r.put({eventId:e,...l,updatedAt:new Date().toISOString()}),t(l)}else c.current?t({current:c.current,versions:c.versions}):t(null)},a.onerror=()=>n(a.error)})}async savePosterConfig(e,t){if(!this.db)throw new Error("DB non ouverte");return new Promise((n,o)=>{const c=this.db.transaction(this.POSTER_CONFIGS_STORE,"readwrite").objectStore(this.POSTER_CONFIGS_STORE).put({eventId:e,...t,updatedAt:new Date().toISOString()});c.onsuccess=()=>{console.log(`[EventsIDBCache] Config affiche (container) pour ${e} sauvegardée`),n()},c.onerror=()=>o(c.error)})}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();r.onsuccess=()=>{const a=r.result,c={lastSync:null};a.forEach(l=>{l.key===this.LAST_SYNC_KEY&&(c.lastSync=l.value)}),console.log(`[EventsIDBCache] Metadata chargées: lastSync=${c.lastSync}`),e(c)},r.onerror=()=>t(r.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.METADATA_STORE,"readwrite");o.objectStore(this.METADATA_STORE).put({key:this.LAST_SYNC_KEY,value:e.lastSync}),o.oncomplete=()=>{console.log("[EventsIDBCache] Metadata sauvegardées"),t()},o.onerror=()=>n(o.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const n=this.db.transaction([this.EVENTS_STORE,this.METADATA_STORE,this.POSTER_CONFIGS_STORE],"readwrite");n.objectStore(this.EVENTS_STORE).clear(),n.objectStore(this.METADATA_STORE).clear(),n.objectStore(this.POSTER_CONFIGS_STORE).clear(),n.oncomplete=()=>{console.log("[EventsIDBCache] Cache vidé"),e()},n.onerror=()=>t(n.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[EventsIDBCache] Connexion fermée"))}}async function ar(){const s=new ir;return await s.open(),s}var A,K,oe,Me,_,re,St,hn,vt,Ce,Fe,Y,an,Ae,Ms;class cr{constructor(){I(this,Y);I(this,A,new st);I(this,K,N(!1));I(this,oe,N(null));I(this,Me,N(!1));I(this,_,null);I(this,re,null);I(this,St,[]);I(this,hn,z(()=>{const e=new Date;return e.setHours(0,0,0,0),Array.from(i(this,A).values()).filter(t=>!t.dateStart||!t.dateEnd?!1:new Date(t.dateEnd)>=e)}));I(this,vt,z(()=>{const e=new Date;return Array.from(i(this,A).values()).filter(t=>t.dateEnd?new Date(t.dateEnd)<e:!1)}));I(this,Ce,null);I(this,Fe,!1)}get loading(){return p(i(this,K))}get error(){return p(i(this,oe))}get isInitialized(){return p(i(this,Me))}get events(){return Array.from(i(this,A).values())}get count(){return i(this,A).size}get currentEvents(){return p(i(this,hn))}get pastEvents(){return p(i(this,vt))}get pastEventsCount(){return p(i(this,vt)).length}async loadCache(){if(p(i(this,Me))){console.log("[EventsStore] Cache déjà chargé");return}console.log("[EventsStore] Chargement du cache..."),m(i(this,K),!0),m(i(this,oe),null);try{if(!k.isAuthenticated)throw new Error("Utilisateur non connecté");j(this,re,k.userId),j(this,St,k.userTeams),j(this,_,await ar());const e=await i(this,_).loadEvents();if(e.size>0){console.log(`[EventsStore] ${e.size} événements chargés depuis le cache`),i(this,A).clear();for(const[t,n]of e)i(this,A).set(t,n)}m(i(this,Me),!0),console.log(`[EventsStore] Cache chargé: ${i(this,A).size} événements`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors du chargement du cache";throw m(i(this,oe),t,!0),console.error("[EventsStore]",t,e),e}finally{m(i(this,K),!1)}}async syncFromRemote(){if(!i(this,_)){console.warn("[EventsStore] Impossible de sync : cache non initialisé");return}console.log("[EventsStore] Synchronisation depuis Appwrite..."),m(i(this,K),!0);try{await S(this,Y,an).call(this),await i(this,_).saveEvents(i(this,A)),await i(this,_).saveMetadata({lastSync:new Date().toISOString()}),console.log(`[EventsStore] Synchronisation terminée: ${i(this,A).size} événements`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors de la synchronisation";throw m(i(this,oe),t,!0),console.error("[EventsStore]",t,e),e}finally{m(i(this,K),!1)}}async setupRealtime(){if(!i(this,_)){console.warn("[EventsStore] Impossible de setup realtime : cache non initialisé");return}if(i(this,Fe)){console.log("[EventsStore] Realtime déjà configuré");return}console.log("[EventsStore] Configuration du realtime..."),await S(this,Y,Ms).call(this),j(this,Fe,!0)}async initialize(){if(p(i(this,Me))){console.log("[EventsStore] Déjà initialisé");return}return i(this,Ce)?(console.log("[EventsStore] Initialisation déjà en cours, attente..."),i(this,Ce)):(console.log("[EventsStore] Initialisation complète..."),m(i(this,K),!0),m(i(this,oe),null),j(this,Ce,(async()=>{try{await this.loadCache(),await this.syncFromRemote(),await this.setupRealtime(),console.log(`[EventsStore] Initialisation complétée: ${i(this,A).size} événements`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors de l'initialisation";throw m(i(this,oe),t,!0),console.error("[EventsStore]",t,e),e}finally{m(i(this,K),!1),j(this,Ce,null)}})()),i(this,Ce))}getEventById(e){return i(this,A).get(e)||null}async fetchEvent(e){try{const t=await Bo(e);if(t){const n=S(this,Y,Ae).call(this,t);return i(this,A).set(e,n),n}return null}catch(t){return console.error(`[EventsStore] Erreur lors du fetch de ${e}:`,t),null}}getEventsByDateRange(e,t){return this.events.filter(n=>n.dateStart&&n.dateEnd&&n.dateStart>=e&&n.dateEnd<=t)}canEditEvent(e){if(!i(this,re))return!1;const t=i(this,A).get(e);return t?!!(t.createdBy===i(this,re)||t.teams?.some(n=>i(this,St).includes(n))||t.contributors&&t.contributors.some(n=>n.id===i(this,re)&&n.status==="accepted")):!1}canUserEditEvent(e,t,n){if(!t)return!1;const o=i(this,A).get(e);return o?!!(o.createdBy===t||o.teams?.length&&n?.length&&o.teams.some(r=>n.includes(r))||o.contributors&&o.contributors.some(r=>r.id===t&&r.status==="accepted")):!1}async createEvent(e){if(!k.userId)throw new Error("Utilisateur non connecté");const t=await Ho(e,k.userId),n=S(this,Y,Ae).call(this,t);return i(this,A).set(t.$id,n),i(this,_)&&await i(this,_).saveEvent(n),console.log(`[EventsStore] Événement créé: ${t.$id}`),n}async createEventWithTeams(e,t=[],n=!0){if(!k.userId)throw new Error("Utilisateur non connecté");const o=await zo(e,k.userId,t,n),r=S(this,Y,Ae).call(this,o);return i(this,A).set(o.$id,r),i(this,_)&&await i(this,_).saveEvent(r),console.log(`[EventsStore] Événement créé avec ${t.length} team(s): ${o.$id}`),r}async updateEvent(e,t){const n=await fs(e,t),o=S(this,Y,Ae).call(this,n);return i(this,A).set(e,o),i(this,_)&&await i(this,_).saveEvent(o),console.log(`[EventsStore] Événement mis à jour: ${e}`),o}async updateEventStatus(e,t){try{await fs(e,{status:t});const n=i(this,A).get(e);n&&(n.status=t),console.log(`[EventsStore] Statut mis à jour: ${e} -> ${t}`)}catch(n){throw console.error(`[EventsStore] Erreur mise à jour statut ${e}:`,n),n}}async deleteEvent(e){await Wo(e),i(this,A).delete(e),i(this,_)&&await i(this,_).deleteEvent(e),console.log(`[EventsStore] Événement supprimé: ${e}`)}getContributors(e){const t=i(this,A).get(e);return t?t.contributors:[]}getContributorStatus(e){const t=i(this,A).get(e);if(!t)return"";const n=t.contributors.filter(o=>o.id===i(this,re));return n.length>0?n[0].status:""}async removeContributor(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const{removeUserFromEvent:o}=await En(async()=>{const{removeUserFromEvent:a}=await Promise.resolve().then(()=>An);return{removeUserFromEvent:a}},void 0);await o(e,t);const r=n.contributors.filter(a=>a.id!==t&&a.email!==t);return n.contributors.length===r.length?n:await this.updateEvent(e,{contributors:r})}catch(n){throw console.error("[EventsStore] Erreur suppression contributeur:",n),n}}async inviteParticipants(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const{teamIds:o=[],emails:r=[],userIds:a=[],sendEmailToExistingMembers:c=!0}=t;if(o.length===0&&r.length===0&&a.length===0)return console.log("[EventsStore] Aucun participant à inviter"),n;const{inviteParticipantsToEvent:l}=await En(async()=>{const{inviteParticipantsToEvent:y}=await Promise.resolve().then(()=>An);return{inviteParticipantsToEvent:y}},void 0),u=await l(e,n.name,{teamIds:o,emails:r,userIds:a,sendEmailToExistingMembers:c});console.log(`[EventsStore] Invitation result: ${u.processed} traités`);const d=o.length>0?2e3:500;await new Promise(y=>setTimeout(y,d));const h=await this.fetchEvent(e);if(!h)throw new Error("Impossible de recharger l'événement");return h}catch(n){throw console.error("[EventsStore] Erreur invitation participants:",n),n}}async removeTeam(e,t){try{const{removeTeamFromEvent:n}=await En(async()=>{const{removeTeamFromEvent:r}=await Promise.resolve().then(()=>An);return{removeTeamFromEvent:r}},void 0);await n(e,t),await new Promise(r=>setTimeout(r,1e3));const o=await this.fetchEvent(e);if(!o)throw new Error("Impossible de recharger l'événement");return console.log(`[EventsStore] Team ${t} retirée de l'événement ${e}`),o}catch(n){throw console.error("[EventsStore] Erreur retrait team:",n),n}}async updateContributorStatus(e,t,n){try{const o=i(this,A).get(e);if(!o)throw new Error("Événement introuvable");const r=[...o.contributors],a=r.findIndex(c=>c.id===t||c.email===t);if(a===-1)throw new Error("Contributeur introuvable");return r[a]={...r[a],status:n,respondedAt:new Date().toISOString()},await this.updateEvent(e,{contributors:r})}catch(o){throw console.error("[EventsStore] Erreur maj statut:",o),o}}getMeals(e){const t=i(this,A).get(e);return t?t.meals:[]}async addMeal(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const o=[...n.meals,t];return await this.updateEvent(e,{meals:o})}catch(n){throw console.error("[EventsStore] Erreur ajout meal:",n),n}}async updateMeal(e,t,n){try{const o=i(this,A).get(e);if(!o)throw new Error("Événement introuvable");const r=[...o.meals];if(t<0||t>=r.length)throw new Error("Index invalide");return r[t]=n,await this.updateEvent(e,{meals:r})}catch(o){throw console.error("[EventsStore] Erreur maj meal:",o),o}}async deleteMeal(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const o=[...n.meals];if(t<0||t>=o.length)throw new Error("Index invalide");return o.splice(t,1),await this.updateEvent(e,{meals:o})}catch(n){throw console.error("[EventsStore] Erreur suppression meal:",n),n}}getTodos(e){const t=i(this,A).get(e);return t?t.todos:[]}async addTodo(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const o=[...n.todos,t];return await this.updateEvent(e,{todos:o})}catch(n){throw console.error("[EventsStore] Erreur ajout todo:",n),n}}async addTodos(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const o=[...n.todos,...t];return await this.updateEvent(e,{todos:o})}catch(n){throw console.error("[EventsStore] Erreur ajout todos:",n),n}}async updateTodoStatus(e,t,n){try{const o=i(this,A).get(e);o&&(o.todos=o.todos.map(c=>c.id===t?{...c,status:n,updatedAt:new Date().toISOString()}:c));const{functions:r,config:a}=await b();await r.createExecution(a.functions.enkaData,JSON.stringify({action:"update_todo_status",data:{eventId:e,todoId:t,status:n}}),!1,"/",ut.POST)}catch(o){throw console.error("[EventsStore] Erreur updateTodoStatus:",o),o}}async toggleTodoAssignment(e,t){try{const n=k.userId;if(!n)throw new Error("Utilisateur non connecté");const o=i(this,A).get(e);if(o){const c=o.todos.find(l=>l.id===t);if(c){let l=[];Array.isArray(c.assignedTo)?l=[...c.assignedTo]:c.assignedTo&&(l=[c.assignedTo]),l.includes(n)?l=l.filter(u=>u!==n):l.push(n),o.todos=o.todos.map(u=>u.id===t?{...u,assignedTo:l.length>0?l:null,updatedAt:new Date().toISOString()}:u)}}const{functions:r,config:a}=await b();await r.createExecution(a.functions.enkaData,JSON.stringify({action:"toggle_todo_assignment",data:{eventId:e,todoId:t}}),!1,"/",ut.POST)}catch(n){throw console.error("[EventsStore] Erreur toggleTodoAssignment:",n),n}}async updateTodo(e,t,n){try{const o=i(this,A).get(e);if(!o)throw new Error("Événement introuvable");const r=o.todos.map(a=>a.id===t?{...a,...n,updatedAt:new Date().toISOString()}:a);return await this.updateEvent(e,{todos:r})}catch(o){throw console.error("[EventsStore] Erreur maj todo:",o),o}}async deleteTodo(e,t){try{const n=i(this,A).get(e);if(!n)throw new Error("Événement introuvable");const o=n.todos.filter(r=>r.id!==t);return await this.updateEvent(e,{todos:o})}catch(n){throw console.error("[EventsStore] Erreur suppression todo:",n),n}}async loadAllPastEvents(){try{if(console.log("[EventsStore] Chargement de TOUS les événements..."),!i(this,re)){console.warn("[EventsStore] userId non défini");return}m(i(this,K),!0);const{events:e}=await hs(i(this,re),null);e.forEach(t=>{i(this,A).set(t.$id,S(this,Y,Ae).call(this,t))}),console.log(`[EventsStore] ${e.length} événements chargés (sans filtre de date, total: ${i(this,A).size})`)}catch(e){throw console.error("[EventsStore] Erreur lors du chargement:",e),e}finally{m(i(this,K),!1)}}calculateScaleFactor(e,t){return e/t}async loadPosterConfig(e){return i(this,_)?await i(this,_).loadPosterConfig(e):null}async savePosterConfig(e,t){if(!i(this,_))return;const o=await i(this,_).loadPosterConfig(e)||{versions:[]};o.current=t,await i(this,_).savePosterConfig(e,o)}async createPosterVersion(e,t,n){if(!i(this,_))return;const r=await i(this,_).loadPosterConfig(e)||{current:t,versions:[]};if(r.versions||(r.versions=[]),r.versions.length>=3)throw new Error("Limite de 3 versions atteinte");const a={id:crypto.randomUUID(),name:n,config:JSON.parse(JSON.stringify(t)),createdAt:new Date().toISOString()};return r.versions.push(a),r.current=t,await i(this,_).savePosterConfig(e,r),a}async deletePosterVersion(e,t){if(!i(this,_))return;const n=await i(this,_).loadPosterConfig(e);!n||!n.versions||(n.versions=n.versions.filter(o=>o.id!==t),await i(this,_).savePosterConfig(e,n))}async reload(){console.log("[EventsStore] Rechargement..."),m(i(this,K),!0),m(i(this,oe),null);try{i(this,A).clear(),await S(this,Y,an).call(this),console.log("[EventsStore] Rechargement complété")}catch(e){const t=e instanceof Error?e.message:"Erreur lors du rechargement";throw m(i(this,oe),t,!0),console.error("[EventsStore]",t,e),e}finally{m(i(this,K),!1)}}async hardReset(){console.log("[EventsStore] 🔄 HARD RESET - Vidage complet..."),m(i(this,K),!0),m(i(this,oe),null);try{i(this,A).clear(),i(this,_)&&(await i(this,_).clear(),console.log("[EventsStore] Cache IDB vidé")),await S(this,Y,an).call(this),i(this,_)&&(await i(this,_).saveEvents(i(this,A)),await i(this,_).saveMetadata({lastSync:new Date().toISOString()}),console.log("[EventsStore] Cache IDB recréé")),console.log("[EventsStore] ✓ HARD RESET terminé")}catch(e){const t=e instanceof Error?e.message:"Erreur lors du hard reset";throw m(i(this,oe),t,!0),console.error("[EventsStore]",t,e),e}finally{m(i(this,K),!1)}}destroy(){i(this,_)&&(i(this,_).close(),j(this,_,null)),i(this,A).clear(),m(i(this,Me),!1),j(this,Fe,!1),console.log("[EventsStore] Ressources nettoyées")}}A=new WeakMap,K=new WeakMap,oe=new WeakMap,Me=new WeakMap,_=new WeakMap,re=new WeakMap,St=new WeakMap,hn=new WeakMap,vt=new WeakMap,Ce=new WeakMap,Fe=new WeakMap,Y=new WeakSet,an=async function(e=null){try{if(console.log("[EventsStore] Chargement des événements..."),!i(this,re)){console.warn("[EventsStore] userId non défini, impossible de charger les événements");return}if(!e){const n=new Date;n.setHours(0,0,0,0);const o=new Date(n);o.setDate(o.getDate()-15),e=o.toISOString()}const{events:t}=await hs(i(this,re),e);t.forEach(n=>{i(this,A).set(n.$id,S(this,Y,Ae).call(this,n))}),console.log(`[EventsStore] ${t.length} événements chargés (filtrés pour userId: ${i(this,re)}, date >= ${e})`)}catch(t){throw console.error("[EventsStore] Erreur lors du chargement:",t),t}},Ae=function(e){return{...e,meals:sr(e.meals),contributors:or(e.contributors),todos:rr(e.todos)}},Ms=async function(){try{console.log("[EventsStore] Activation du Realtime...");const e=Te();Vt.register([`databases.${e}.collections.${Ve}.documents`],async t=>{const n=t.events.some(r=>r.includes(".create"))?"create":t.events.some(r=>r.includes(".delete"))?"delete":"update",o=t.payload;if(console.log(`[EventsStore] ⚡️ Realtime RECEIVED: ${n} pour ${o.$id}`,{name:o.name,updatedAt:o.$updatedAt}),n==="create"||n==="update"){const r=S(this,Y,Ae).call(this,o);i(this,A).set(o.$id,r),i(this,_)&&await i(this,_).saveEvent(r)}else n==="delete"&&(i(this,A).delete(o.$id),i(this,_)&&await i(this,_).deleteEvent(o.$id))}),console.log("[EventsStore] Realtime enregistré auprès du manager")}catch(e){console.error("[EventsStore] Erreur lors de la configuration du realtime:",e)}};const Ue=new cr;function Kt(s){if(!s)return[];const e=[],t=s.$id;return e.push(U.read(W.label(t)),U.update(W.label(t))),e}function lr(s,e){switch(s){case"store":return{store:JSON.stringify(e)};case"who":return{who:e.names};default:throw new Error(`Unsupported update type: ${s}`)}}function ur(s,e,t){return{$id:s.$id,productHugoUuid:s.productHugoUuid,productName:s.productName,mainId:s.mainId,status:s.status||null,who:e.who!==void 0?e.who:s.who,store:e.store!==void 0?e.store:s.store,stockReel:s.stockReel||null,previousNames:s.previousNames||null,isMerged:s.isMerged||!1,mergedFrom:s.mergedFrom||null,mergeDate:s.mergeDate||null,mergeReason:s.mergeReason||null,mergedInto:s.mergedInto||null,totalNeededOverride:s.totalNeededOverride||null,$permissions:[U.read(W.label(t)),U.update(W.label(t))]}}function dr(s,e){return{$id:s.$id,mainId:s.mainId,productHugoUuid:s.productHugoUuid,productName:s.productName,...e}}async function pr(s){const{account:e}=await b(),t=await e.get();return{...s,updatedBy:t.name}}function Un(){return localStorage.getItem("appwrite-user-name")||""}async function hr(s,e,t=100){try{const{tables:n,config:o}=await b(),r=await n.listRows({databaseId:o.databaseId,tableId:o.collections.purchases,queries:[g.greaterThan("$updatedAt",e),g.equal("mainId",s),g.limit(t)]});return console.log(`[Appwrite Interactions] ${r.rows.length} purchases modifiés chargés`),r.rows}catch(n){return console.error("[Appwrite Interactions] Erreur chargement purchases modifiés:",n),[]}}async function fr(s,e){const{lastSync:t,limit:n=1e3}=e;try{const{tables:o,config:r}=await b();if(!t){console.log("[Appwrite Interactions] Chargement complet des produits et achats");const y=(await o.listRows({databaseId:r.databaseId,tableId:r.collections.products,queries:[g.equal("mainId",s),g.limit(n)]})).rows,E=(await o.listRows({databaseId:r.databaseId,tableId:r.collections.purchases,queries:[g.equal("mainId",s),g.limit(n*2)]})).rows,R=new Map;return y.forEach(Q=>{R.set(Q.$id,{...Q,purchases:[]})}),E.forEach(Q=>{Q.products?.forEach(V=>{const L=R.get(V);L&&(L.purchases||(L.purchases=[]),L.purchases.push(Q))})}),console.log(`[Appwrite Interactions] ${y.length} produits chargés avec ${E.length} achats`),Array.from(R.values())}const a=await o.listRows({databaseId:r.databaseId,tableId:r.collections.products,queries:[g.greaterThan("$updatedAt",t),g.equal("mainId",s),g.limit(n)]}),c=a.rows,u=(await o.listRows({databaseId:r.databaseId,tableId:r.collections.purchases,queries:[g.greaterThan("$updatedAt",t),g.equal("mainId",s),g.limit(n*2)]})).rows,d=new Map;return c.forEach(h=>{d.set(h.$id,{...h,purchases:[]})}),u.forEach(h=>{h.products?.forEach(y=>{const w=d.get(y);w&&(w.purchases||(w.purchases=[]),w.purchases.push(h))})}),a.rows.length>0&&console.log(`[Appwrite Interactions] ${a.rows.length} produits synchronisés (delta)`),Array.from(d.values())}catch(o){console.error(`[Appwrite Interactions] Erreur sync produits avec purchases pour mainId ${s}:`,o);const r=o instanceof Error?o.message:"Erreur lors de la synchronisation";throw new Error(`Échec de la synchronisation: ${r}`)}}async function rt(s,e,t=!0){const{tables:n,config:o}=await b();return t&&(e.updatedBy=Un()),await n.updateRow({databaseId:o.databaseId,tableId:o.collections.products,rowId:s,data:e})}async function mr(s,e,t){try{const n=t(s);if(!n)throw new Error(`Produit ${s} non trouvé localement pour création`);console.log(`[Appwrite Interactions] Création produit ${s} sur Appwrite...`);const o=dr(n,e),r=await pr(o),{tables:a,config:c}=await b(),l=Ue.getEventById(r.mainId),u=Kt(l),d=await a.createRow({databaseId:c.databaseId,tableId:c.collections.products,rowId:s,data:r,permissions:u});return console.log(`[Appwrite Interactions] Produit ${s} créé avec permissions (labels + teams)`),d}catch(n){console.error(`[Appwrite Interactions] Erreur création produit ${s}:`,n);const o=n instanceof Error?n.message:"Erreur inconnue";throw new Error(`Échec de la création du produit: ${o}`)}}async function oi(s,e){try{const{tables:t,config:n}=await b(),r=`${Ss(s.productName).substring(0,10)}_${Date.now().toString(36)}`,a={quantity:s.quantity,pF:s.pF||!1,pS:s.pS||!1},c={productHugoUuid:null,productName:s.productName,productType:s.productType||"Autre",store:s.store?JSON.stringify(s.store):null,who:s.who||[],isSynced:!0,mainId:e,status:"active",updatedBy:Un(),stockReel:null,isMerged:!1,mergedFrom:null,mergeDate:null,mergeReason:null,mergedInto:null,totalNeededOverride:null,specs:JSON.stringify(a)};console.log(`[Appwrite Interactions] Création produit manuel ${r}...`,c);const l=Ue.getEventById(e),u=Kt(l),d=await t.createRow({databaseId:n.databaseId,tableId:n.collections.products,rowId:r,data:c,permissions:u});return console.log(`[Appwrite Interactions] Produit manuel ${r} créé avec permissions Label`),d}catch(t){throw console.error("[Appwrite Interactions] Erreur création produit manuel:",t),t}}async function ri(s,e){if(!s)throw new Error("ID du produit requis pour la mise à jour du magasin");const t=e?JSON.stringify(e):null,n=await rt(s,{store:t||void 0});return console.log(`[Appwrite Interactions] Magasin mis à jour pour produit ${s}, nouvelle valeur:`,n.store),n}async function ii(s,e){return rt(s,{who:e})}async function ai(s,e){return rt(s,{stockReel:e})}async function ci(s,e,t=!1){if(!s)throw new Error("ID du produit requis pour la mise à jour de l'override");const n=JSON.stringify(e),o=await rt(s,{totalNeededOverride:n},t);return console.log(`[Appwrite Interactions] Total override mis à jour pour le produit ${s}:`,e),o}async function li(s,e=!0){if(!s)throw new Error("ID du produit requis pour la suppression de l'override");const t=await rt(s,{totalNeededOverride:""},e);return console.log(`[Appwrite Interactions] Total override supprimé pour le produit ${s}`),t}async function ui(s,e,t){try{const n=t(s);if(!n)throw new Error(`Produit ${s} non trouvé localement pour mise à jour batch`);const o={};return e.stockReel!==void 0&&(o.stockReel=e.stockReel),e.who!==void 0&&(o.who=e.who),e.storeInfo!==void 0&&(o.store=JSON.stringify(e.storeInfo)),n.isSynced?(console.log(`[Appwrite Interactions] Produit ${s} déjà sync, update batch normal...`),await rt(s,o)):(console.log(`[Appwrite Interactions] Produit ${s} local, création batch avec upsert...`),await mr(s,o,t))}catch(n){throw console.error(`[Appwrite Interactions] Erreur lors de la mise à jour batch du produit ${s}:`,n),n}}async function di(s){const{tables:e,config:t}=await b(),n={...s,createdBy:Un()},o=Ue.getEventById(s.mainId),r=Kt(o),a=await e.createRow(t.databaseId,t.collections.purchases,le.unique(),n,r);return console.log("[Appwrite Interactions] Achat créé avec permissions Label:",a),a}async function pi(s,e){try{const{tables:t,config:n}=await b(),o=await t.updateRow(n.databaseId,n.collections.purchases,s,e);return console.log(`[Appwrite Interactions] Achat ${s} mis à jour:`,e),o}catch(t){console.error(`[Appwrite Interactions] Erreur mise à jour achat ${s}:`,t);const n=t instanceof Error?t.message:"Erreur inconnue";throw new Error(`Échec de la mise à jour de l'achat: ${n}`)}}async function hi(s){try{const{tables:e,config:t}=await b();await e.deleteRow(t.databaseId,t.collections.purchases,s),console.log(`[Appwrite Interactions] Achat ${s} supprimé`)}catch(e){console.error(`[Appwrite Interactions] Erreur suppression achat ${s}:`,e);const t=e instanceof Error?e.message:"Erreur inconnue";throw new Error(`Échec de la suppression de l'achat: ${t}`)}}async function yr(s){if(!s?.length)return[];try{const{tables:e,config:t}=await b(),n=await e.listRows(t.databaseId,t.collections.purchases,[g.equal("$id",s)]);return console.log(`[Appwrite Interactions] ${n.rows.length} purchases chargés avec relations products`),n.rows}catch(e){console.error("[Appwrite Interactions] Erreur chargement purchases avec relations:",e);const t=e instanceof Error?e.message:"Erreur inconnue";throw new Error(`Échec du chargement des purchases: ${t}`)}}async function fi(s,e,t,n){try{const{functions:o,config:r,account:a}=await b(),c=qr.currentMainId;if(!c)throw new Error("No current event - cannot determine mainId for permissions");const l=await a.get(),u=lr(t,n),d=s.map(E=>{const R=e.find(Q=>Q.$id===E);if(!R)throw new Error(`Product ${E} not found in products data`);return ur(R,u,c)});console.log(`[Appwrite Interactions] Lancement mise à jour groupée OPTIMISÉE: ${d.length} produits, type: ${t}`);const h={operation:"batchUpdateProductsOptimized",data:{rows:d,fromUserId:l.$id}},y=await Ps(()=>o.createExecution(r.functions.batchUpdate,JSON.stringify(h),!1,"/",ut.POST),{operationName:`batchUpdateProductsOptimized (${d.length} products, type: ${t})`,maxAutoRetries:1,autoRetryDelay:2e3});if(!y)throw new Error("Opération annulée ou échouée après tentatives de mise à jour groupée optimisée");if(y.status!=="completed")throw new Error(`Exécution échouée avec statut: ${y.status}. Erreur: ${y.stderr||y.responseBody}`);const w=JSON.parse(y.responseBody);return w.success?console.log(`[Appwrite Interactions] Mise à jour groupée optimisée réussie: ${w.updatedCount} produits mis à jour`):console.error("[Appwrite Interactions] Mise à jour groupée optimisée échouée:",w.error),w}catch(o){console.error("[Appwrite Interactions] Erreur mise à jour groupée optimisée:",o);const r=o instanceof Error?o.message:"Erreur inconnue";return{success:!1,updatedCount:s.length,updateType:t,error:r,timestamp:new Date().toISOString()}}}async function mi(s,e,t,n={}){try{const{tables:o,config:r,account:a}=await b(),c=await a.get(),l=Ue.getEventById(s),u=Kt(l),d=[];console.log("[Appwrite Interactions] Debug createQuickValidationPurchases:",{mainId:s,productId:e,productIdType:typeof e,quantities:t,options:n});for(const h of t){const y={products:[e],mainId:s,quantity:h.q,unit:h.u,status:"delivered",notes:n.notes||`Validation rapide ${new Date().toLocaleDateString("fr-FR")}`,store:n.store??null,who:c.name,price:null,orderDate:null,deliveryDate:null,createdBy:c.$id,invoiceId:n.invoiceId,invoiceTotal:null},w=await o.createRow(r.databaseId,r.collections.purchases,le.unique(),y,u);d.push(w)}return console.log(`[Appwrite Interactions] ${d.length} validations rapides créées avec permissions (labels + teams) pour produit ${e}`),d}catch(o){console.error("[Appwrite Interactions] Erreur création validation rapide:",o);const r=o instanceof Error?o.message:"Erreur inconnue";throw new Error(`Échec de la validation rapide: ${r}`)}}async function yi(s,e,t,n,o,r){try{const{tables:a,config:c,account:l}=await b(),u=await l.get(),d=e||le.unique(),h=u.name;if(!t)throw new Error("invoiceTotal est requis pour une dépense");const y=Ue.getEventById(s),w=Kt(y),E={products:[],mainId:s,quantity:1,unit:"global",status:"expense",notes:o||"",store:n??null,who:h||u.name,price:t,invoiceId:d,invoiceTotal:t,orderDate:null,deliveryDate:null,createdBy:u.$id},R=await a.createRow(c.databaseId,c.collections.purchases,le.unique(),E,w);return console.log("[Appwrite Interactions] Dépense créée avec permissions (labels + teams):",R),R}catch(a){console.error("[Appwrite Interactions] Erreur création dépense:",a);const c=a instanceof Error?a.message:"Erreur inconnue";throw new Error(`Échec de la création de la dépense: ${c}`)}}async function gr(s){try{const{tables:e,config:t}=await b(),n=await e.listRows(t.databaseId,t.collections.purchases,[g.equal("mainId",s),g.equal("status","expense"),g.limit(1e3)]);return console.log(`[Appwrite Interactions] ${n.rows.length} dépenses globales chargées`),n.rows}catch(e){return console.error("[Appwrite Interactions] Erreur chargement dépenses globales:",e),[]}}class wr{constructor(e){C(this,"dbName");C(this,"db",null);C(this,"version",1);C(this,"PRODUCTS_STORE","products");C(this,"METADATA_STORE","metadata");C(this,"LAST_SYNC_KEY","lastSync");C(this,"ALL_DATES_KEY","allDates");C(this,"HUGO_HASH_KEY","hugoContentHash");this.dbName=`products-cache-${e}`}async open(){if(!this.db)return new Promise((e,t)=>{const n=indexedDB.open(this.dbName,this.version);n.onerror=()=>t(n.error),n.onsuccess=()=>{this.db=n.result,console.log(`[IDBCache] Base ouverte: ${this.dbName}`),e()},n.onupgradeneeded=o=>{const r=o.target.result;r.objectStoreNames.contains(this.PRODUCTS_STORE)||(r.createObjectStore(this.PRODUCTS_STORE,{keyPath:"$id"}),console.log("[IDBCache] Object store 'products' créé")),r.objectStoreNames.contains(this.METADATA_STORE)||(r.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[IDBCache] Object store 'metadata' créé avec keyPath"))}})}async loadProducts(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.PRODUCTS_STORE,"readonly").objectStore(this.PRODUCTS_STORE).getAll();r.onsuccess=()=>{const a=new Map;r.result.forEach(c=>{a.set(c.$id,c)}),console.log(`[IDBCache] ${a.size} produits chargés`),e(a)},r.onerror=()=>t(r.error)})}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();r.onsuccess=()=>{const a=r.result,c={lastSync:null,allDates:[],hugoContentHash:null};a.forEach(l=>{l.key===this.LAST_SYNC_KEY?c.lastSync=l.value:l.key===this.ALL_DATES_KEY?c.allDates=l.value||[]:l.key===this.HUGO_HASH_KEY&&(c.hugoContentHash=l.value)}),console.log(`[IDBCache] Metadata chargées: lastSync=${c.lastSync}, dates=${c.allDates?.length||0}, hash=${c.hugoContentHash}`),e(c)},r.onerror=()=>t(r.error)})}async saveProducts(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.PRODUCTS_STORE,"readwrite"),r=o.objectStore(this.PRODUCTS_STORE);r.clear(),e.forEach(a=>{r.put(a)}),o.oncomplete=()=>{console.log(`[IDBCache] ${e.size} produits sauvegardés`),t()},o.onerror=()=>n(o.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.METADATA_STORE,"readwrite"),r=o.objectStore(this.METADATA_STORE);r.put({key:this.LAST_SYNC_KEY,value:e.lastSync}),r.put({key:this.ALL_DATES_KEY,value:e.allDates}),e.hugoContentHash!==void 0&&r.put({key:this.HUGO_HASH_KEY,value:e.hugoContentHash}),o.oncomplete=()=>{console.log("[IDBCache] Metadata sauvegardées (objets {key, value})"),t()},o.onerror=()=>n(o.error)})}async updateLastSync(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.LAST_SYNC_KEY,value:e});a.onsuccess=()=>{console.log(`[IDBCache] lastSync mis à jour: ${e}`),t()},a.onerror=()=>n(a.error)})}async updateAllDates(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.ALL_DATES_KEY,value:e});a.onsuccess=()=>{console.log(`[IDBCache] allDates mis à jour: ${e.length} dates`),t()},a.onerror=()=>n(a.error)})}async updateHugoContentHash(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.HUGO_HASH_KEY,value:e});a.onsuccess=()=>{console.log(`[IDBCache] hugoContentHash mis à jour: ${e}`),t()},a.onerror=()=>n(a.error)})}async updateLastHugoMenuUpdate(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:"lastHugoMenuUpdate",value:e});a.onsuccess=()=>{console.log("[IDBCache] lastHugoMenuUpdate sauvegardé"),t()},a.onerror=()=>n(a.error)})}async upsertProduct(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.PRODUCTS_STORE,"readwrite").objectStore(this.PRODUCTS_STORE).put(e);a.onsuccess=()=>t(),a.onerror=()=>n(a.error)})}async deleteProduct(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.PRODUCTS_STORE,"readwrite").objectStore(this.PRODUCTS_STORE).delete(e);a.onsuccess=()=>t(),a.onerror=()=>n(a.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const n=this.db.transaction([this.PRODUCTS_STORE,this.METADATA_STORE],"readwrite");n.objectStore(this.PRODUCTS_STORE).clear(),n.objectStore(this.METADATA_STORE).clear(),n.oncomplete=()=>{console.log("[IDBCache] Cache vidé"),e()},n.onerror=()=>t(n.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[IDBCache] Connexion fermée"))}}async function Ir(s){const e=new wr(s);return await e.open(),e}var Rt,At;class it{constructor(e,t){I(this,Rt,N(ce({})));C(this,"dateStore");I(this,At,z(()=>{const e=this.dateStore.current;this.dateStore.dates;let t;if(e.start&&e.end)t=bo(this.data,e.start,e.end);else return{quantities:[],formattedQuantities:"",nbRecipes:0,totalAssiettes:0,stockResult:[],availableQuantities:[],missingQuantities:[],formattedMissingQuantities:"",formattedAvailableQuantities:"En attente",hasAvailable:!1,hasMissing:!1,concernedDates:[],recipesByDate:new Map};return{quantities:t.requiredQuantities,formattedQuantities:t.requiredQuantitiesFormatted,nbRecipes:t.totalRecipesInRange,totalAssiettes:t.totalPortionsInRange,stockResult:t.stockBalance,availableQuantities:t.availableStockQuantities,missingQuantities:t.missingStockQuantities,formattedMissingQuantities:t.missingStockFormatted,formattedAvailableQuantities:t.availableStockFormatted,hasAvailable:t.hasAvailableStock,hasMissing:t.hasMissingStock,concernedDates:t.datesInSelectedRange,recipesByDate:t.recipesByDate}}));this.data=e,this.dateStore=t}get data(){return p(i(this,Rt))}set data(e){m(i(this,Rt),e,!0)}update(e){this.data=e}get $id(){return this.data.$id}get productName(){return this.data.productName}get productType(){return this.data.productType}get storeInfo(){return this.data.storeInfo}get who(){return this.data.who}get pF(){return this.data.pF}get pS(){return this.data.pS}get status(){return this.data.status}get previousNames(){return this.data.previousNames}get purchases(){return this.data.purchases}get totalNeededOverrideParsed(){return this.data.totalNeededOverrideParsed}get displayMissingQuantity(){return this.data.displayMissingQuantity}get missingQuantityArray(){return this.data.missingQuantityArray}get isSynced(){return this.data.isSynced}get byDate(){return this.data.byDate}get stats(){return p(i(this,At))}set stats(e){m(i(this,At),e)}}Rt=new WeakMap,At=new WeakMap;var H,O,J,Tt,Pt,$t,Dt,Mt,Ct,_t,Nt,qt;class br{constructor(e=[]){I(this,H,N(ce([])));I(this,O,N(null));I(this,J,N(null));I(this,Tt,z(()=>[...p(i(this,H))].sort()[0]));I(this,Pt,z(()=>[...p(i(this,H))].sort()[p(i(this,H)).length-1]));I(this,$t,z(()=>{if(p(i(this,H)).length===0)return!0;const e=this.lastAvailableDate?new Date(this.lastAvailableDate):new Date;return e.setHours(23,59,59,999),e<new Date}));I(this,Dt,z(()=>{if(p(i(this,H)).length===0)return!1;const e=new Date;return e.setHours(0,0,0,0),p(i(this,H)).some(t=>new Date(t)>=e)}));I(this,Mt,z(()=>p(i(this,O))===this.firstAvailableDate&&p(i(this,J))===this.lastAvailableDate));I(this,Ct,z(()=>{if(p(i(this,H)).length===0)return!1;const e=[...p(i(this,H))].sort(),t=new Date;t.setHours(0,0,0,0);const n=e.find(a=>new Date(a)>=t)||null;let o,r;if(n)o=n,r=e[e.length-1];else{const a=e[e.length-1];o=a,r=a}return p(i(this,O))===o&&p(i(this,J))===r}));I(this,_t,z(()=>p(i(this,H)).length===1));I(this,Nt,z(()=>!!(p(i(this,O))&&p(i(this,O))===p(i(this,J)))));I(this,qt,z(()=>{if(!p(i(this,O))||!p(i(this,J))||this.isEventPassed)return!1;const e=new Date(p(i(this,O)));return e.setHours(e.getHours()+vs),e<new Date}));m(i(this,H),e,!0),this.initializeSmartRange()}get start(){return p(i(this,O))}get end(){return p(i(this,J))}get dates(){return p(i(this,H))}get firstAvailableDate(){return p(i(this,Tt))}set firstAvailableDate(e){m(i(this,Tt),e)}get lastAvailableDate(){return p(i(this,Pt))}set lastAvailableDate(e){m(i(this,Pt),e)}get current(){return{start:p(i(this,O)),end:p(i(this,J))}}get isEventPassed(){return p(i(this,$t))}set isEventPassed(e){m(i(this,$t),e)}get hasUpcomingDates(){return p(i(this,Dt))}set hasUpcomingDates(e){m(i(this,Dt),e)}get isFullRange(){return p(i(this,Mt))}set isFullRange(e){m(i(this,Mt),e)}get isUpcomingRange(){return p(i(this,Ct))}set isUpcomingRange(e){m(i(this,Ct),e)}get hasSingleDateEvent(){return p(i(this,_t))}set hasSingleDateEvent(e){m(i(this,_t),e)}get hasSingleDateInRange(){return p(i(this,Nt))}set hasSingleDateInRange(e){m(i(this,Nt),e)}get hasPastDatesInRange(){return p(i(this,qt))}set hasPastDatesInRange(e){m(i(this,qt),e)}setAvailableDates(e){m(i(this,H),e,!0),this.initializeSmartRange()}setRange(e,t){if(!e&&!t){m(i(this,O),null),m(i(this,J),null);return}if(!e||!t){const r=e||t;m(i(this,O),r,!0),m(i(this,J),r,!0);return}const n=new Date(e)<=new Date(t)?e:t,o=new Date(e)>=new Date(t)?e:t;m(i(this,O),n,!0),m(i(this,J),o,!0)}selectAll(){p(i(this,H)).length!==0&&(m(i(this,O),p(i(this,H))[0],!0),m(i(this,J),p(i(this,H))[p(i(this,H)).length-1],!0))}selectUpcoming(){if(p(i(this,H)).length===0)return;const e=[...p(i(this,H))].sort(),t=new Date;t.setHours(0,0,0,0);const n=e.find(o=>new Date(o)>=t)||null;if(n)m(i(this,O),n,!0),m(i(this,J),e[e.length-1],!0);else{const o=e[e.length-1];m(i(this,O),o,!0),m(i(this,J),o,!0)}}selectFutureDatesOnly(){const e=new Date;e.setDate(e.getDate()+1),e.setHours(0,0,0,0);const t=p(i(this,H)).filter(n=>new Date(n)>=e);t.length>0&&(m(i(this,O),t[0],!0),m(i(this,J),t[t.length-1],!0))}initializeSmartRange(){if(p(i(this,H)).length===0)return;const e=[...p(i(this,H))].sort(),t=this.isEventPassed,n=new Date(e[0])<new Date,o=new Date;let r;t?r=e[0]:n?r=o.toISOString().slice(0,19)+"Z":r=e[0],m(i(this,O),r,!0),m(i(this,J),e[e.length-1],!0),console.log(`[DateRangeStore] Initialized: ${p(i(this,O))} - ${p(i(this,J))}`)}reset(){m(i(this,H),[],!0),m(i(this,O),null),m(i(this,J),null),console.log("[DateRangeStore] Reset")}}H=new WeakMap,O=new WeakMap,J=new WeakMap,Tt=new WeakMap,Pt=new WeakMap,$t=new WeakMap,Dt=new WeakMap,Mt=new WeakMap,Ct=new WeakMap,_t=new WeakMap,Nt=new WeakMap,qt=new WeakMap;class Er{constructor(){C(this,"dbName","recipes-cache");C(this,"db",null);C(this,"version",5);C(this,"RECIPES_INDEX_STORE","recipes-index");C(this,"RECIPES_DETAILS_STORE","recipes-details");C(this,"METADATA_STORE","metadata");C(this,"BUILD_TIMESTAMP_KEY","buildTimestamp");C(this,"LAST_APPWRITE_SYNC_KEY","lastAppwriteSync");C(this,"RECIPES_COUNT_KEY","recipesCount")}async open(){if(this.db)return;const e=()=>new Promise((a,c)=>{const l=indexedDB.open(this.dbName,this.version);l.onerror=()=>c(l.error),l.onsuccess=()=>a(l.result),l.onupgradeneeded=u=>{const d=u.target.result;d.objectStoreNames.contains(this.RECIPES_INDEX_STORE)||(d.createObjectStore(this.RECIPES_INDEX_STORE,{keyPath:"$id"}),console.log("[RecipesIDBCache] Object store 'recipes-index' créé")),d.objectStoreNames.contains(this.RECIPES_DETAILS_STORE)||(d.createObjectStore(this.RECIPES_DETAILS_STORE,{keyPath:"$id"}),console.log("[RecipesIDBCache] Object store 'recipes-details' créé")),d.objectStoreNames.contains(this.METADATA_STORE)||(d.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[RecipesIDBCache] Object store 'metadata' créé"))}});let t=await e();const n=t.objectStoreNames.contains(this.RECIPES_INDEX_STORE),o=t.objectStoreNames.contains(this.RECIPES_DETAILS_STORE),r=t.objectStoreNames.contains(this.METADATA_STORE);(!n||!o||!r)&&(console.warn(`[RecipesIDBCache] Base corrompue détectée (index=${n}, details=${o}, metadata=${r}), suppression et recréation...`),t.close(),await new Promise((a,c)=>{const l=indexedDB.deleteDatabase(this.dbName);l.onsuccess=()=>a(),l.onerror=()=>c(l.error),l.onblocked=()=>{console.warn("[RecipesIDBCache] Suppression bloquée, réessai...")}}),t=await e()),this.db=t,console.log(`[RecipesIDBCache] Base ouverte: ${this.dbName}`)}async loadRecipesIndex(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.RECIPES_INDEX_STORE,"readonly").objectStore(this.RECIPES_INDEX_STORE).getAll();r.onsuccess=()=>{const a=new Map;r.result.forEach(c=>{a.set(c.$id,c)}),console.log(`[RecipesIDBCache] ${a.size} recettes (index) chargées`),e(a)},r.onerror=()=>t(r.error)})}async saveRecipesIndex(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.RECIPES_INDEX_STORE,"readwrite"),r=o.objectStore(this.RECIPES_INDEX_STORE);r.clear(),e.forEach(a=>{r.put(a)}),o.oncomplete=()=>{console.log(`[RecipesIDBCache] ${e.size} recettes (index) sauvegardées`),t()},o.onerror=()=>n(o.error)})}async loadRecipeDetail(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.RECIPES_DETAILS_STORE,"readonly").objectStore(this.RECIPES_DETAILS_STORE).get(e);a.onsuccess=()=>{const c=a.result;c&&console.log(`[RecipesIDBCache] Détails de ${e} chargés depuis le cache`),t(c||null)},a.onerror=()=>n(a.error)})}async saveRecipeDetail(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.RECIPES_DETAILS_STORE,"readwrite").objectStore(this.RECIPES_DETAILS_STORE).put(e);a.onsuccess=()=>{console.log(`[RecipesIDBCache] Détails de ${e.$id} sauvegardés`),t()},a.onerror=()=>n(a.error)})}async loadAllRecipeDetails(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.RECIPES_DETAILS_STORE,"readonly").objectStore(this.RECIPES_DETAILS_STORE).getAll();r.onsuccess=()=>{const a=new Map;r.result.forEach(c=>{a.set(c.$id,c)}),console.log(`[RecipesIDBCache] ${a.size} détails de recettes chargés`),e(a)},r.onerror=()=>t(r.error)})}async loadRecipeDetailsBulk(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const r=this.db.transaction(this.RECIPES_DETAILS_STORE,"readonly").objectStore(this.RECIPES_DETAILS_STORE),a=new Map;let c=0;const l=e.length;for(const u of e){const d=r.get(u);d.onsuccess=()=>{const h=d.result;h&&a.set(u,h),c++,c===l&&(console.log(`[RecipesIDBCache] ${a.size}/${l} recettes chargées en bulk`),t(a))},d.onerror=()=>{console.warn(`[RecipesIDBCache] Erreur chargement ${u} en bulk:`,d.error),c++,c===l&&(console.log(`[RecipesIDBCache] ${a.size}/${l} recettes chargées en bulk (avec erreurs)`),t(a))}}l===0&&(console.log("[RecipesIDBCache] 0 recettes à charger en bulk"),t(a))})}async saveRecipeDetailsBulk(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.RECIPES_DETAILS_STORE,"readwrite"),r=o.objectStore(this.RECIPES_DETAILS_STORE);let a=0;const c=e.size;e.forEach(l=>{const u=r.put(l);u.onsuccess=()=>{a++,a===c&&(console.log(`[RecipesIDBCache] ${c} recettes sauvegardées en bulk`),t())},u.onerror=()=>{console.error(`[RecipesIDBCache] Erreur sauvegarde ${l.$id} en bulk:`,u.error),n(u.error)}}),c===0&&(console.log("[RecipesIDBCache] 0 recettes à sauvegarder en bulk"),t()),o.onerror=()=>n(o.error)})}async deleteRecipeDetail(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const a=this.db.transaction(this.RECIPES_DETAILS_STORE,"readwrite").objectStore(this.RECIPES_DETAILS_STORE).delete(e);a.onsuccess=()=>t(),a.onerror=()=>n(a.error)})}async deleteRecipeFromIndex(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction([this.RECIPES_INDEX_STORE,this.RECIPES_DETAILS_STORE],"readwrite"),r=o.objectStore(this.RECIPES_INDEX_STORE),a=o.objectStore(this.RECIPES_DETAILS_STORE);r.delete(e),a.delete(e),o.oncomplete=()=>{console.log(`[RecipesIDBCache] Recette ${e} supprimée de l'index et des détails`),t()},o.onerror=()=>n(o.error)})}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const r=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();r.onsuccess=()=>{const a=r.result,c={buildTimestamp:null,lastAppwriteSync:null,recipesCount:0,cacheVersion:1};a.forEach(l=>{l.key===this.RECIPES_COUNT_KEY?c.recipesCount=l.value:l.key===this.BUILD_TIMESTAMP_KEY?c.buildTimestamp=l.value:l.key===this.LAST_APPWRITE_SYNC_KEY&&(c.lastAppwriteSync=l.value)}),console.log(`[RecipesIDBCache] Metadata chargées: count=${c.recipesCount}, build=${c.buildTimestamp}, sync=${c.lastAppwriteSync}`),e(c)},r.onerror=()=>t(r.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,n)=>{const o=this.db.transaction(this.METADATA_STORE,"readwrite"),r=o.objectStore(this.METADATA_STORE);r.put({key:this.BUILD_TIMESTAMP_KEY,value:e.buildTimestamp}),r.put({key:this.LAST_APPWRITE_SYNC_KEY,value:e.lastAppwriteSync}),r.put({key:this.RECIPES_COUNT_KEY,value:e.recipesCount}),o.oncomplete=()=>{console.log("[RecipesIDBCache] Metadata sauvegardées"),t()},o.onerror=()=>n(o.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const n=this.db.transaction([this.RECIPES_INDEX_STORE,this.RECIPES_DETAILS_STORE,this.METADATA_STORE],"readwrite");n.objectStore(this.RECIPES_INDEX_STORE).clear(),n.objectStore(this.RECIPES_DETAILS_STORE).clear(),n.objectStore(this.METADATA_STORE).clear(),n.oncomplete=()=>{console.log("[RecipesIDBCache] Cache vidé"),e()},n.onerror=()=>t(n.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[RecipesIDBCache] Connexion fermée"))}}async function Sr(){const s=new Er;return await s.open(),s}function gi(s){return s.map(e=>JSON.stringify(e))}function cn(s){return!s||!Array.isArray(s)?[]:s.map(e=>{try{return JSON.parse(e)}catch(t){return console.warn("[ingredientUtils] Failed to parse ingredient:",e,t),null}}).filter(e=>e!==null)}const ys={"Bouchées salées":"sandwich",Boisson:"cup-soda",Cake:"cake-slice","Crèmes dessert":"fast-food-pudding",Friture:"fryer",Gateau:"cake-slice",Pain:"bread","Plat au Four":"oven","Plat en Sauce":"pot",Salade:"lettuce",Sauce:"sauce",Snacking:"hamburger",Soupe:"soup","Tarte (salée)":"pizza","Tarte (sucrée)":"pie",Tartinade:"tartinade"},vr={entree:"salad",plat:"dish",dessert:"fast-food-pudding"};function wi(s,e){const t=Array.isArray(e)?e[0]:e;if(t&&ys[t])return{label:t,iconId:ys[t]};const n=Rr(s),o=vr[s]||"no-cat";return{label:n,iconId:o}}function Rr(s){switch(s){case"entree":return"Entrée";case"plat":return"Plat";case"dessert":return"Dessert";default:return s}}function vn(s){return!s||!Array.isArray(s)?[]:s.map(e=>{try{const t=JSON.parse(e);if(t&&typeof t.astuce=="string")return t;if(typeof e=="string")return{astuce:e}}catch(t){console.warn("[recipeUtils] Failed to parse astuce:",e,t)}return null}).filter(e=>e!==null)}function Ii(s){return!s||!Array.isArray(s)||s.length===0?null:s.map(e=>JSON.stringify(typeof e=="string"?{astuce:e}:e))}function Ar(s){if(!s||typeof s!="object"||Array.isArray(s))throw new Error(`Format d'ingrédient invalide: ${JSON.stringify(s)}`);return{uuid:s.uuid||"",name:s.name||"",originalQuantity:s.originalQuantity||0,originalUnit:s.originalUnit||"",normalizedQuantity:s.normalizedQuantity||0,normalizedUnit:s.normalizedUnit||"",comment:s.comment||"",allergens:Array.isArray(s.allergens)?s.allergens:[],type:s.type||"",pF:s.pF??!1,pS:s.pS??!1}}function gs(s){if(!s||typeof s!="object")throw new Error("Données de recette invalides");const e=[];return Array.isArray(s.ingredients)&&s.ingredients.forEach(t=>{try{e.push(Ar(t))}catch(n){console.warn("[parseRecipeData] Ingrédient invalide ignoré:",n)}}),{...s,$id:s.$id||s.id||"",$createdAt:s.$createdAt||s.createdAt||"",$updatedAt:s.$updatedAt||s.updatedAt||"",ingredients:e}}function Tr(s){if(!s||typeof s!="object")throw new Error("Données d'index de recette invalides");const e=[];return Array.isArray(s.ingredients)&&s.ingredients.forEach(t=>{typeof t=="string"?e.push(t):t&&typeof t.name=="string"&&e.push(t.name)}),{title:s.title||"",typeR:s.typeR||"",categories:Array.isArray(s.categories)?s.categories:[],regime:s.regime||null,draft:s.draft??!1,materiel:Array.isArray(s.materiel)?s.materiel:[],region:s.region||"",serveHot:s.serveHot??!1,cuisson:s.cuisson??!1,check:s.check??!1,saison:Array.isArray(s.saison)?s.saison:[],permissionWrite:Array.isArray(s.permissionWrite)?s.permissionWrite:[],lockedBy:s.lockedBy||null,plate:s.plate??100,ingredients:e,auteur:s.auteur||"",createdBy:s.createdBy||"",$id:s.$id||s.id||"",$createdAt:s.$createdAt||s.createdAt||"",$updatedAt:s.$updatedAt||s.updatedAt||""}}function on(s){let e=[];return s.ingredients&&(e=cn(s.ingredients).map(n=>n.name)),{title:s.title,typeR:s.typeR,categories:s.categories,regime:s.regime,draft:s.draft||!1,saison:s.saison,ingredients:e,materiel:s.materiel,region:s.region||null,serveHot:s.serveHot,cuisson:s.cuisson,check:s.check,auteur:s.auteur||s.createdBy,permissionWrite:s.permissionWrite,lockedBy:s.lockedBy||null,$id:s.$id,$createdAt:s.$createdAt,$updatedAt:s.$updatedAt,createdBy:s.createdBy,plate:s.plate,rootRecipeId:s.rootRecipeId||null,versionLabel:s.versionLabel||null}}function Pr(s,e){const t=s.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,""),n=e?e.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"").replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,""):"";let o;if(n){const r=t.slice(0,16),a=n.slice(0,5);o=`${r}-${a}`}else o=t.slice(0,22);return`${o}_${so(12).toLowerCase()}`}async function bi(s,e,t,n,o=!1){try{const{functions:r,config:a}=await b(),c=a.functions.enkaData,l=JSON.stringify({action:s,recipeId:e,userId:t,data:n}),u=await r.createExecution({functionId:c,body:l,async:o});if(o){if(u.status==="failed")throw new Error(`Function execution failed to start: ${u.status}`);return{success:!0,executionId:u.$id}}if(u.status!=="completed")throw new Error(`Function execution failed: ${u.status} - ${u.responseBody}`);const d=JSON.parse(u.responseBody);if(!d.success)throw new Error(d.error||"Unknown error in manage_recipe");return d.data}catch(r){throw console.error(`[appwrite-recipes] Error executing manage_recipe (${s}):`,r),r}}const Ke="recettes";async function ws(){try{const{tables:s,config:e}=await b();return(await s.listRows({databaseId:e.databaseId,tableId:Ke})).rows}catch(s){throw console.error("[appwrite-recipes] Error listing all recipes:",s),s}}async function $r(s){try{const{tables:e,config:t}=await b(),n=[g.greaterThan("$updatedAt",s)];return(await e.listRows({databaseId:t.databaseId,tableId:Ke,queries:n})).rows}catch(e){throw console.error(`[appwrite-recipes] Error listing updated recipes since ${s}:`,e),e}}async function Rn(s){try{const{tables:e,config:t}=await b();return await e.getRow({databaseId:t.databaseId,tableId:Ke,rowId:s})}catch(e){if(e.code===404)return null;throw console.error(`[appwrite-recipes] Error getting recipe ${s}:`,e),e}}async function Ei(s,e){try{const{tables:t,config:n,account:o}=await b(),r=Pr(s.title,s.versionLabel||void 0),a=[U.read(W.users()),U.update(W.user(e)),U.delete(W.user(e))],l=(await o.get()).name,u={title:s.title,plate:s.plate,ingredients:s.ingredients,preparation:s.preparation,draft:s.draft??!0,typeR:s.typeR,categories:s.categories??[],regime:s.regime??[],check:s.check??!1,description:s.description??null,quantite_desc:s.quantite_desc??null,region:s.region??null,saison:s.saison??[],cuisson:s.cuisson??[],serveHot:s.serveHot??!0,auteur:l,preparation24h:s.preparation24h??null,astuces:s.astuces??null,publishedAt:s.publishedAt||new Date().toISOString().split("T")[0]+"T00:00:00Z",$id:r,createdBy:e,permissionWrite:s.permissionWrite||[e],rootRecipeId:s.rootRecipeId??null,versionLabel:s.versionLabel??null},d=await t.createRow({databaseId:n.databaseId,tableId:Ke,rowId:r,data:u,permissions:a});return console.log(`[appwrite-recipes] Recipe created: ${r}`),d}catch(t){throw console.error("[appwrite-recipes] Error creating recipe:",t),t}}async function Dr(s,e,t){try{const{tables:n,config:o}=await b(),r={...e,check:e.check??!1,...e.publishedAt&&{publishedAt:e.publishedAt}},a=await n.updateRow({databaseId:o.databaseId,tableId:Ke,rowId:s,data:r});return console.log(`[appwrite-recipes] Recipe updated: ${s}`),a}catch(n){throw console.error(`[appwrite-recipes] Error updating recipe ${s}:`,n),n}}async function Si(s){try{const{tables:e,config:t}=await b();await e.updateRow({databaseId:t.databaseId,tableId:Ke,rowId:s,data:{status:"deleted"}}),console.log(`[appwrite-recipes] Recipe soft deleted: ${s}`)}catch(e){throw console.error(`[appwrite-recipes] Error deleting recipe ${s}:`,e),e}}const Mr="/api/data.json";var q,ee,te,_e,jt,$,fe,Ne,et,Z,$n,Cs,_s,Dn,Mn;class Cr{constructor(){I(this,Z);I(this,q,N(ce(new st)));I(this,ee,N(!1));I(this,te,N(null));I(this,_e,N(!1));I(this,jt,N(null));I(this,$,null);I(this,fe,new Set);I(this,Ne,null);I(this,et,!1)}get loading(){return p(i(this,ee))}get error(){return p(i(this,te))}get isInitialized(){return p(i(this,_e))}get recipesIndex(){return Array.from(p(i(this,q)).values())}get count(){return p(i(this,q)).size}getAllRecipes(){return Array.from(p(i(this,q)).values())}async loadCache(){if(p(i(this,_e))){console.log("[RecipesStore] Cache déjà chargé");return}console.log("[RecipesStore] Chargement du cache..."),m(i(this,ee),!0),m(i(this,te),null);try{j(this,$,await Sr());const e=await i(this,$).loadRecipesIndex(),t=await i(this,$).loadMetadata();e.size>0&&(console.log(`[RecipesStore] ${e.size} recettes (index) chargées depuis le cache`),m(i(this,q),new st(e),!0)),m(i(this,_e),!0),console.log(`[RecipesStore] Cache chargé: ${p(i(this,q)).size} recettes`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors du chargement du cache";throw m(i(this,te),t,!0),console.error("[RecipesStore]",t,e),e}finally{m(i(this,ee),!1)}}async syncFromRemote(){if(!i(this,$)){console.warn("[RecipesStore] Impossible de sync : cache non initialisé");return}console.log("[RecipesStore] Synchronisation depuis sources distantes..."),m(i(this,ee),!0);try{const e=await i(this,$).loadMetadata();try{await S(this,Z,$n).call(this,e)}catch(t){if(console.error("[RecipesStore] Erreur chargement data.json:",t),p(i(this,q)).size===0)throw new Error("Aucun cache disponible et data.json inaccessible");console.log("[RecipesStore] Continuation avec les données du cache")}if(k.userId)try{await S(this,Z,Cs).call(this,e)}catch(t){console.warn("[RecipesStore] Erreur sync Appwrite:",t)}console.log(`[RecipesStore] Synchronisation terminée: ${p(i(this,q)).size} recettes`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors de la synchronisation";throw m(i(this,te),t,!0),console.error("[RecipesStore]",t,e),e}finally{m(i(this,ee),!1)}}async setupRealtime(){if(!i(this,$)){console.warn("[RecipesStore] Impossible de setup realtime : cache non initialisé");return}if(i(this,et)){console.log("[RecipesStore] Realtime déjà configuré");return}if(console.log("[RecipesStore] Configuration du realtime..."),k.userId)try{S(this,Z,_s).call(this),j(this,et,!0)}catch(e){console.warn("[RecipesStore] Erreur activation realtime:",e)}}async initialize(){if(p(i(this,_e))){console.log("[RecipesStore] Déjà initialisé");return}return i(this,Ne)?(console.log("[RecipesStore] Initialisation déjà en cours, attente..."),i(this,Ne)):(console.log("[RecipesStore] Initialisation..."),m(i(this,ee),!0),m(i(this,te),null),j(this,Ne,(async()=>{try{if(await this.loadCache(),await this.syncFromRemote(),await this.setupRealtime(),p(i(this,q)).size===0){const e="Aucune recette disponible après initialisation";m(i(this,te),e),console.warn("[RecipesStore]",e)}console.log(`[RecipesStore] Initialisation complétée: ${p(i(this,q)).size} recettes`)}catch(e){const t=e instanceof Error?e.message:"Erreur lors de l'initialisation";throw m(i(this,te),t,!0),console.error("[RecipesStore] ECHEC Initialisation:",t,e),e}finally{m(i(this,ee),!1),j(this,Ne,null)}})()),i(this,Ne))}async forceReloadAllRecipes(){if(!k.userId)throw new Error("Utilisateur non connecté");m(i(this,ee),!0),m(i(this,te),null);try{console.log("[RecipesStore] Rechargement forcé des recettes Appwrite...");const e=await ws();let t=0,n=0;if(e.forEach(o=>{o.status==="deleted"?p(i(this,q)).has(o.$id)&&(p(i(this,q)).delete(o.$id),n++,console.log(`[RecipesStore] Recette ${o.$id} supprimée (status=deleted)`)):(p(i(this,q)).set(o.$id,on(o)),t++)}),console.log(`[RecipesStore] ${t} recettes Appwrite chargées, ${n} supprimées`),i(this,$)){const o=await i(this,$).loadMetadata(),r=new Date().toISOString();await i(this,$).saveRecipesIndex(p(i(this,q))),await i(this,$).saveMetadata({...o,lastAppwriteSync:r,recipesCount:p(i(this,q)).size,cacheVersion:1})}console.log("[RecipesStore] Rechargement forcé terminé")}catch(e){const t=e instanceof Error?e.message:"Erreur lors du rechargement";throw m(i(this,te),t,!0),console.error("[RecipesStore] Erreur rechargement forcé:",e),e}finally{m(i(this,ee),!1)}}async hardReset(){if(!k.userId)throw new Error("Utilisateur non connecté");console.log("[RecipesStore] 🔄 HARD RESET - Vidage complet..."),m(i(this,ee),!0),m(i(this,te),null);try{p(i(this,q)).clear(),i(this,$)&&(await i(this,$).clear(),console.log("[RecipesStore] Cache IDB vidé")),await S(this,Z,$n).call(this,null);const e=await ws();let t=0,n=0;if(e.forEach(o=>{o.status!=="deleted"?(p(i(this,q)).set(o.$id,on(o)),t++):n++}),console.log(`[RecipesStore] ${t} recettes Appwrite chargées, ${n} supprimées ignorées`),i(this,$)){const o=new Date().toISOString();await i(this,$).saveRecipesIndex(p(i(this,q))),await i(this,$).saveMetadata({buildTimestamp:p(i(this,jt)),lastAppwriteSync:o,recipesCount:p(i(this,q)).size,cacheVersion:1}),console.log("[RecipesStore] Cache IDB recréé")}console.log("[RecipesStore] ✓ HARD RESET terminé")}catch(e){const t=e instanceof Error?e.message:"Erreur lors du hard reset";throw m(i(this,te),t,!0),console.error("[RecipesStore] Erreur hard reset:",e),e}finally{m(i(this,ee),!1)}}getRecipeIndexByUuid(e){return p(i(this,q)).get(e)||null}searchRecipes(e){if(!e.trim())return this.recipesIndex;const t=S(this,Z,Dn).call(this,e.trim()).split(/\s+/);return this.recipesIndex.filter(n=>{const r=S(this,Z,Dn).call(this,n.title).split(/[\s\-_]+/);return t.every(a=>r.some(c=>c.startsWith(a)))})}get availableTypes(){const e=new Set;return this.recipesIndex.forEach(t=>e.add(t.typeR)),Array.from(e).sort()}async canEditRecipe(e){if(!k.userId)return!1;try{const t=await Rn(e);return t?t.createdBy===k.userId||!!t.permissionWrite?.includes(k.userId)||!!t.teams?.some(n=>k.userTeams.includes(n)):!1}catch(t){return console.error(`[RecipesStore] Erreur lors de la vérification des permissions pour ${e}:`,t),!1}}getRecipeLockStatus(e){return p(i(this,q)).get(e)?.lockedBy||null}async updateRecipeLock(e,t){if(k.userId)try{await Dr(e,{lockedBy:t},k.userId),console.log(`[RecipesStore] Verrou ${e} mis à jour: ${t||"libéré"}`);const n=p(i(this,q)).get(e);n&&p(i(this,q)).set(e,{...n,lockedBy:t})}catch(n){throw console.error(`[RecipesStore] Erreur verrouillage ${e}:`,n),n}}async getRecipeByUuid(e){if(i(this,fe).has(e)){for(console.log(`[RecipesStore] Chargement de ${e} déjà en cours, attente...`);i(this,fe).has(e);)await new Promise(t=>setTimeout(t,50));return i(this,$)&&await i(this,$).loadRecipeDetail(e)||null}i(this,fe).add(e);try{if(i(this,$)){const n=await i(this,$).loadRecipeDetail(e);if(n)return n}let t=null;try{const n=`/recettes/${e}/recipe.json`,o=await fetch(n);if(o.ok){const r=await o.json();t=gs(r),console.log(`[RecipesStore] ${e} chargée depuis Hugo`)}}catch{console.log(`[RecipesStore] ${e} non trouvée dans Hugo`)}if(!t&&k.userId)try{const n=await Rn(e);if(n){const o=cn(n.ingredients||[]);t={...n,ingredients:o,astuces:vn(n.astuces),prepAlt:n.prepAlt||null,categories:n.categories,regime:n.regime,saison:n.saison,teams:n.teams,permissionWrite:n.permissionWrite},console.log(`[RecipesStore] ${e} chargée depuis Appwrite (fallback)`)}}catch{console.log(`[RecipesStore] ${e} non trouvée dans Appwrite`)}return t&&i(this,$)&&await i(this,$).saveRecipeDetail(t),t||console.warn(`[RecipesStore] ${e} non trouvée (Hugo ni Appwrite)`),t}catch(t){return console.error(`[RecipesStore] Erreur lors du chargement de ${e}:`,t),null}finally{i(this,fe).delete(e)}}async getRecipesByUuidsBulk(e){const t=performance.now(),n=[...new Set(e.filter(Boolean))];if(n.length===0)return new Map;console.log(`[RecipesStore] Chargement bulk de ${n.length} recettes...`);const o=new Map;i(this,$)&&(await i(this,$).loadRecipeDetailsBulk(n)).forEach((d,h)=>o.set(h,d));const r=n.filter(u=>!o.has(u));console.log(`[RecipesStore] Bulk: ${o.size} dans le cache, ${r.length} à fetch`);const a=new Map;if(r.length>0){r.forEach(u=>i(this,fe).add(u));try{const u=r.map(async h=>{let y=null;try{const w=`/recettes/${h}/recipe.json`,E=await fetch(w);if(E.ok){const R=await E.json();y=gs(R)}}catch{}if(!y&&k.userId)try{const w=await Rn(h);if(w){const E=cn(w.ingredients||[]);y={...w,ingredients:E,astuces:vn(w.astuces),prepAlt:w.prepAlt||null,categories:w.categories,regime:w.regime,saison:w.saison,teams:w.teams,permissionWrite:w.permissionWrite}}}catch{}return y?{uuid:h,recipe:y}:null});(await Promise.all(u)).forEach(h=>{h&&a.set(h.uuid,h.recipe)}),a.size>0&&i(this,$)&&await i(this,$).saveRecipeDetailsBulk(a),r.forEach(h=>i(this,fe).delete(h))}catch(u){console.error("[RecipesStore] Erreur lors du fetch bulk:",u),r.forEach(d=>i(this,fe).delete(d))}}const c=new Map([...o,...a]),l=performance.now()-t;return console.log(`[RecipesStore] Bulk terminé: ${c.size}/${n.length} recettes en ${l.toFixed(0)}ms`),c}async preloadRecipes(e){console.log(`[RecipesStore] Préchargement de ${e.length} recettes...`);const t=e.map(n=>this.getRecipeByUuid(n));await Promise.all(t),console.log("[RecipesStore] Préchargement terminé")}async getVariantGroup(e,t=2){const n=this.getRecipeIndexByUuid(e);if(!n)return{root:null,variants:[],isRoot:!1};const o=new Map,r=new Set;let a=n;for(;a.rootRecipeId&&!r.has(a.rootRecipeId);){r.add(a.$id);const l=this.getRecipeIndexByUuid(a.rootRecipeId);if(!l)break;a=l}const c=a;return o.set(c.$id,c),await S(this,Z,Mn).call(this,c.$id,o,new Set([c.$id]),0,t),{root:c,variants:Array.from(o.values()),isRoot:!n.rootRecipeId||n.rootRecipeId===n.$id}}findRootRecipe(e){const t=new Set;let n=e,o=10;for(let r=0;r<o;r++){const a=this.getRecipeIndexByUuid(n);if(!a||!a.rootRecipeId)return n;if(t.has(n))return console.error("[RecipesStore] Cycle détecté dans rootRecipeId, retour à",e),e;t.add(n),n=a.rootRecipeId}return e}destroy(){i(this,$)&&(i(this,$).close(),j(this,$,null)),p(i(this,q)).clear(),m(i(this,_e),!1),j(this,et,!1),console.log("[RecipesStore] Ressources nettoyées")}}q=new WeakMap,ee=new WeakMap,te=new WeakMap,_e=new WeakMap,jt=new WeakMap,$=new WeakMap,fe=new WeakMap,Ne=new WeakMap,et=new WeakMap,Z=new WeakSet,$n=async function(e){try{console.log("[RecipesStore] Chargement data.json...");const t=await fetch(Mr);if(!t.ok)throw new Error(`Erreur HTTP: ${t.status}`);const n=await t.json();if(!Array.isArray(n.recipes))throw new Error("Format invalide: recipes n'est pas un tableau");const o=n.meta?.timestamp;if(m(i(this,jt),o,!0),o&&e&&e.buildTimestamp&&e.buildTimestamp>=o){console.log(`[RecipesStore] Cache à jour (Ts: ${e.buildTimestamp} >= ${o})`);return}console.log(`[RecipesStore] Nouvelle version détectée ou cache manquant (Ts: ${o}), Traitement...`);const r=n.recipes.map(c=>Tr(c));let a=0;r.forEach(c=>{const l=p(i(this,q)).get(c.$id);let u=!1;if(!l)u=!0;else{const d=new Date(c.$updatedAt).getTime(),h=new Date(l.$updatedAt).getTime();d>h&&(u=!0)}u&&(p(i(this,q)).set(c.$id,c),a++)}),console.log(`[RecipesStore] Smart Merge: ${a} recettes mises à jour/ajoutées.`),i(this,$)&&(await i(this,$).saveRecipesIndex(p(i(this,q))),await i(this,$).saveMetadata({...e,buildTimestamp:o||Date.now()/1e3,recipesCount:p(i(this,q)).size,cacheVersion:1}))}catch(t){throw console.error("[RecipesStore] Erreur loadIndexFromDataJson:",t),t}},Cs=async function(e){console.log("[RecipesStore] Sync incrémentiel Appwrite...");const t=e?.lastAppwriteSync||"1970-01-01T00:00:00.000Z";e?.buildTimestamp&&new Date(e.buildTimestamp*1e3).toISOString(),console.log(`[RecipesStore] Sync Appwrite: depuis ${t}`);const n=await $r(t);if(n.length===0){console.log("[RecipesStore] Aucune mise à jour Appwrite détectée.");return}console.log(`[RecipesStore] ${n.length} recettes mises à jour depuis Appwrite.`);let o=0,r=0;n.forEach(c=>{if(c.status==="deleted")p(i(this,q)).has(c.$id)&&(p(i(this,q)).delete(c.$id),r++,console.log(`[RecipesStore] Recette ${c.$id} supprimée (status=deleted)`));else{const l=on(c);p(i(this,q)).set(l.$id,l),o++}});const a=new Date().toISOString();i(this,$)&&(await i(this,$).saveRecipesIndex(p(i(this,q))),await i(this,$).saveMetadata({...e,lastAppwriteSync:a})),console.log(`[RecipesStore] Sync incrémentiel terminé (${o} mises à jour, ${r} supprimées).`)},_s=async function(){try{console.log("[RecipesStore] Configuration du Realtime...");const e=Te();Vt.register([`databases.${e}.collections.${Ke}.documents`],async t=>{const n=t.payload;let o="update";if(t.events.some(r=>r.includes(".create"))?o="create":t.events.some(r=>r.includes(".delete"))&&(o="delete"),console.log(`[RecipesStore] ⚡️ Realtime RECEIVED: ${o} pour ${n.$id}`),o==="create"||o==="update"){if(n.status==="deleted"){if(p(i(this,q)).delete(n.$id),i(this,$))try{await i(this,$).deleteRecipeFromIndex(n.$id),console.log(`[RecipesStore] Recette ${n.$id} supprimée de l'index (status=deleted)`)}catch(l){console.warn(`[RecipesStore] Erreur suppression index ${n.$id}:`,l)}return}const r=on(n);p(i(this,q)).set(n.$id,r);const a=cn(n.ingredients),c={...n,ingredients:a,astuces:vn(n.astuces)};if(i(this,$))try{await i(this,$).saveRecipeDetail(c),console.log(`[RecipesStore] Détails de ${n.$id} mis à jour dans le cache`)}catch(l){console.warn(`[RecipesStore] Erreur mise à jour cache détails ${n.$id}:`,l)}}else if(o==="delete"&&(p(i(this,q)).delete(n.$id),i(this,$)))try{await i(this,$).deleteRecipeFromIndex(n.$id),console.log(`[RecipesStore] Recette ${n.$id} supprimée du cache`)}catch(r){console.warn(`[RecipesStore] Erreur suppression cache ${n.$id}:`,r)}}),console.log("[RecipesStore] Realtime enregistré auprès du manager")}catch(e){console.error("[RecipesStore] Erreur lors de la configuration du realtime:",e)}},Dn=function(e){return e.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"")},Mn=async function(e,t,n,o,r){if(!(o>r))for(const[a,c]of p(i(this,q)))t.has(a)||c.rootRecipeId===e&&(t.set(a,c),c.rootRecipeId&&c.rootRecipeId!==e&&!n.has(c.rootRecipeId)&&(n.add(c.rootRecipeId),await S(this,Z,Mn).call(this,c.rootRecipeId,t,n,o+1,r)))};const Is=new Cr,bs=1e3;var D,ie,X,ue,qe,kt,tt,Oe,Qe,ne,x,je,Ut,P,Lt,xt,Bt,Ht,zt,fn,Wt,Gt,mn,T,Ns,nt,Ee,qs,js,ln,un,ks,Cn,Nr,ct,Us,Ls,xs,Bs,Hs,dn,zs,Ws,Gs,Ot,Qt;class _r{constructor(){I(this,T);I(this,D,new st);I(this,ie,new st);I(this,X,N(null));I(this,ue,N(null));I(this,qe,N(!1));I(this,kt,N(!1));I(this,tt,N(null));I(this,Oe,N(!1));I(this,Qe,N(!1));I(this,ne,N(null));C(this,"dateStore",new br);I(this,x,null);I(this,je,null);I(this,Ut,N(ce([])));I(this,P,N(ce({searchQuery:"",selectedStores:[],selectedWho:[],selectedProductTypes:[],selectedTemperatures:[],temperatureFilter:"all",completionStatus:"all",groupBy:"productType",sortColumn:"",sortDirection:"asc"})));I(this,Lt,z(()=>{const e=Array.from(i(this,D).values()).map(t=>t.data);return console.log(`[ProductsStore] enrichedProducts recalculated: ${e.length} products`),e}));I(this,xt,z(()=>{if(console.log("[Store] Filtering products by date range (Map)"),!this.dateRange.start||!this.dateRange.end)return new Map;const e=new Date(this.dateRange.start),t=new Date(this.dateRange.end),n=new Map;for(const[o,r]of i(this,D)){const a=r.data,c=!a.productHugoUuid;if(!a.byDate&&!c||!mo(a,p(i(this,P))))continue;if(p(i(this,P)).completionStatus!=="all"){const d=r.stats.hasMissing;if(p(i(this,P)).completionStatus==="completed"&&d||p(i(this,P)).completionStatus==="incomplete"&&!d)continue}let u=!1;if(a.byDate){const d=new Date(e);d.setHours(0,0,0,0);const h=new Date(t);h.setHours(23,59,59,999),u=Object.keys(a.byDate).some(y=>{const w=new Date(y);return w>=d&&w<=h})}(u||c)&&n.set(o,r)}return n}));I(this,Bt,z(()=>({total:i(this,D).size,frais:Array.from(i(this,D).values()).filter(e=>e.pF).length,surgel:Array.from(i(this,D).values()).filter(e=>e.pS).length,merged:Array.from(i(this,D).values()).filter(e=>e.data.isMerged).length})));I(this,Ht,z(()=>{const e=Array.from(i(this,D).values()).map(t=>t.storeInfo?.storeName).filter(Boolean);return[...new Set(e)]}));I(this,zt,z(()=>{if(!p(i(this,ue)))return[];const e=Ue.getEventById(p(i(this,ue)));return e?.contributors?e.contributors.filter(t=>t.status==="accepted"&&t.name?.trim()).map(t=>t.name.trim()).sort():[]}));I(this,fn,z(()=>{const e=Array.from(i(this,D).values()).flatMap(t=>t.who||[]);return[...new Set(e)].sort()}));I(this,Wt,z(()=>{const e=new Set([...this.eventContributors,...p(i(this,fn))]);return Array.from(e).sort()}));I(this,Gt,z(()=>{const e=Array.from(i(this,D).values()).map(t=>t.productType).filter(Boolean);return[...new Set(e)]}));I(this,mn,z(()=>{const t=Array.from(this.filteredProductsMap.values()).sort((a,c)=>a.$id.localeCompare(c.$id));if(p(i(this,P)).groupBy==="none")return{"":t};const n=Object.groupBy(t,a=>p(i(this,P)).groupBy==="store"?a.storeInfo?.storeName||"Non défini":a.productType||"Non défini"),o=Object.keys(n).sort((a,c)=>a===""?1:c===""?-1:a.localeCompare(c)),r={};return o.forEach(a=>{r[a]=n[a]}),r}));I(this,nt,"");I(this,Ee,null);C(this,"setSearchQuery",io(e=>{p(i(this,P)).searchQuery=e},()=>500));I(this,Ot,z(()=>{let e=0,t=0;for(const n of i(this,D).values())n.stats.hasMissing?t++:e++;return{completed:e,missing:t,total:e+t}}));I(this,Qt,z(()=>{let e=0;const t={},n={},o=[];for(const r of i(this,ie).values()){const a=r.invoiceTotal||r.price||0;e+=a;const c=r.store||"Non défini";t[c]=(t[c]||0)+a;const l=r.who||"Non défini";n[l]=(n[l]||0)+a,o.push(r)}for(const r of i(this,D).values()){const a=r.data;if(a.purchases&&a.purchases.length>0){for(const c of a.purchases)if(c.price){e+=c.price;const l=c.store||"Non défini";t[l]=(t[l]||0)+c.price;const u=c.who||"Non défini";n[u]=(n[u]||0)+c.price;const d={...c,_productName:a.productName};o.push(d)}}}return o.sort((r,a)=>{const c=new Date(r.orderDate||r.$createdAt).getTime();return new Date(a.orderDate||a.$createdAt).getTime()-c}),{totalGlobal:e,byStore:t,byWho:n,allPurchases:o}}))}get currentMainId(){return p(i(this,X))}get dateRange(){return this.dateStore.current}get availableDates(){return this.dateStore.dates}get isEventPassed(){return this.dateStore.isEventPassed}get hasSingleDateEvent(){return this.dateStore.hasSingleDateEvent}get hasSingleDateInRange(){return this.dateStore.hasSingleDateInRange}get hasPastDatesInRange(){return this.dateStore.hasPastDatesInRange}get hasPendingConflicts(){return p(i(this,Ut)).length>0}get pendingConflicts(){return p(i(this,Ut))}get filters(){return p(i(this,P))}get hasFilters(){return this.filters.searchQuery!==""||this.filters.selectedStores.length>0||this.filters.selectedWho.length>0||this.filters.selectedProductTypes.length>0||this.filters.selectedTemperatures.length>0||this.filters.temperatureFilter!=="all"||this.filters.completionStatus!=="all"}get groupedFilteredProducts(){return p(i(this,mn))}get loading(){return p(i(this,kt))}get error(){return p(i(this,tt))}get lastSync(){return p(i(this,ne))}get syncing(){return p(i(this,Oe))}setDateRange(e,t){this.dateStore.setRange(e,t)}isFullRange(){return this.dateStore.isFullRange}initializeDateRange(){this.dateStore.initializeSmartRange()}selectUpcomingDates(){this.dateStore.selectUpcoming()}isUpcomingRange(){return this.dateStore.isUpcomingRange}get firstAvailableDate(){return this.dateStore.firstAvailableDate}get lastAvailableDate(){return this.dateStore.lastAvailableDate}selectFutureDatesOnly(){this.dateStore.selectFutureDatesOnly()}get realtimeConnected(){return p(i(this,Qe))}get enrichedProducts(){return p(i(this,Lt))}set enrichedProducts(e){m(i(this,Lt),e)}get filteredProductsMap(){return p(i(this,xt))}set filteredProductsMap(e){m(i(this,xt),e)}get stats(){return p(i(this,Bt))}set stats(e){m(i(this,Bt),e)}get uniqueStores(){return p(i(this,Ht))}set uniqueStores(e){m(i(this,Ht),e)}get eventContributors(){return p(i(this,zt))}set eventContributors(e){m(i(this,zt),e)}get uniqueWho(){return p(i(this,Wt))}set uniqueWho(e){m(i(this,Wt),e)}get uniqueProductTypes(){return p(i(this,Gt))}set uniqueProductTypes(e){m(i(this,Gt),e)}async initialize(e){if(!e?.trim())throw new Error("eventId invalide fourni");if(p(i(this,qe))&&p(i(this,ue))===e){console.log(`[ProductsStore] Déjà initialisé pour eventId: ${e}`);return}p(i(this,qe))&&p(i(this,ue))!==e&&(console.log(`[ProductsStore] Changement d'événement: ${p(i(this,ue))} → ${e}, reset...`),this.reset()),console.log(`[ProductsStore] Initialisation avec eventId: ${e}`);const t=Ue.getEventById(e);if(!t)throw new Error(`Événement ${e} introuvable dans EventsStore`);try{m(i(this,ue),t.$id,!0),m(i(this,X),t.$id,!0),k.setCurrentMainId(p(i(this,X))),console.log(`[ProductsStore] Initialisation du cache IDB pour mainId: ${p(i(this,X))}`),j(this,x,await Ir(p(i(this,X)))),await S(this,T,js).call(this),i(this,D).size===0&&(console.log("[ProductsStore] Cache vide, calcul depuis event.meals..."),await S(this,T,qs).call(this,t),await S(this,T,ln).call(this)),this.dateStore.setAvailableDates([...t.allDates||[]]),this.initializeDateRange(),await this.syncFromAppwrite(),await S(this,T,Gs).call(this),m(i(this,qe),!0);const n=S(this,T,zs).call(this);S(this,T,Ws).call(this,n),i(this,Ee)&&i(this,Ee).call(this),j(this,Ee,oo(()=>{ro(()=>{const o=Ue.getEventById(e);o&&S(this,T,Ns).call(this,o)})})),console.log(`[ProductsStore] Initialisation complétée: ${i(this,D).size} produits`)}catch(n){const o=n instanceof Error?n.message:"Erreur lors de l'initialisation";throw m(i(this,tt),o,!0),console.error("[ProductsStore]",o,n),n}}async syncFromAppwrite(){if(p(i(this,X))){m(i(this,Oe),!0),console.log(`[ProductsStore] Début syncFromAppwrite pour mainId: ${p(i(this,X))}`);try{console.log(`[ProductsStore] Récupération des produits modifiés depuis lastSync: ${p(i(this,ne))}`);const e=await fr(p(i(this,X)),{lastSync:p(i(this,ne)),limit:bs});if(console.log(`[ProductsStore] ${e.length} produits récupérés depuis Appwrite`),e.forEach(t=>{const n=i(this,D).get(t.$id);console.log(`[ProductsStore] Sync produit ${t.$id}: existing=${!!n}, who=${t.who}, store=${t.store}`);const o=S(this,T,Cn).call(this,t,n?.data);o.isSynced=!0,o.status="active",n?n.update(o):i(this,D).set(t.$id,new it(o,this.dateStore))}),p(i(this,ne))){console.log(`[ProductsStore] Récupération des purchases modifiés depuis lastSync: ${p(i(this,ne))}`);const t=await hr(p(i(this,X)),p(i(this,ne)),bs);console.log(`[ProductsStore] ${t.length} purchases modifiés récupérés`),t.forEach(n=>{if(n.status==="expense")i(this,ie).set(n.$id,n);else if(n.products?.length){const o=n.products.map(r=>typeof r=="string"?r:r.$id);S(this,T,dn).call(this,o,n)}})}S(this,T,ks).call(this),await S(this,T,ln).call(this),console.log("[ProductsStore] SyncFromAppwrite terminé avec succès")}catch(e){throw console.error("[ProductsStore] Erreur lors du sync:",e),e}finally{m(i(this,Oe),!1)}}}toggleProductType(e){const t=p(i(this,P)).selectedProductTypes.indexOf(e);t>-1?p(i(this,P)).selectedProductTypes.splice(t,1):p(i(this,P)).selectedProductTypes.push(e)}toggleTemperature(e){const t=p(i(this,P)).selectedTemperatures.indexOf(e);t>-1?p(i(this,P)).selectedTemperatures.splice(t,1):p(i(this,P)).selectedTemperatures.push(e)}setTemperatureFilter(e){p(i(this,P)).temperatureFilter=e}clearTypeAndTemperatureFilters(){p(i(this,P)).selectedProductTypes=[],p(i(this,P)).selectedTemperatures=[],p(i(this,P)).temperatureFilter="all"}setGroupBy(e){p(i(this,P)).groupBy=e}toggleStore(e){const t=p(i(this,P)).selectedStores.indexOf(e);t>-1?p(i(this,P)).selectedStores.splice(t,1):p(i(this,P)).selectedStores.push(e)}toggleWho(e){const t=p(i(this,P)).selectedWho.indexOf(e);t>-1?p(i(this,P)).selectedWho.splice(t,1):p(i(this,P)).selectedWho.push(e)}clearStoreFilters(){p(i(this,P)).selectedStores=[]}clearWhoFilters(){p(i(this,P)).selectedWho=[]}setCompletionStatus(e){p(i(this,P)).completionStatus=e}handleSort(e){p(i(this,P)).sortColumn===e?p(i(this,P)).sortDirection=p(i(this,P)).sortDirection==="asc"?"desc":"asc":(p(i(this,P)).sortColumn=e,p(i(this,P)).sortDirection="asc")}clearFilters(){m(i(this,P),{searchQuery:"",selectedStores:[],selectedWho:[],selectedProductTypes:[],selectedTemperatures:[],temperatureFilter:"all",completionStatus:"all",groupBy:"productType",sortColumn:"",sortDirection:"asc"},!0)}sortProducts(e){return p(i(this,P)).sortColumn?[...e].sort((t,n)=>{let o=t[p(i(this,P)).sortColumn],r=n[p(i(this,P)).sortColumn];return p(i(this,P)).sortColumn==="totalNeededConsolidated"?(o=parseFloat(o)||0,r=parseFloat(r)||0):p(i(this,P)).sortColumn==="purchases"&&(o=t.purchases?.length||0,r=n.purchases?.length||0),o<r?p(i(this,P)).sortDirection==="asc"?-1:1:o>r?p(i(this,P)).sortDirection==="asc"?1:-1:0}):e}getEnrichedProductById(e){return i(this,D).get(e)?.data??null}getProductModelById(e){return i(this,D).get(e)??null}hasConversions(e){const t=i(this,D).get(e)?.data;return t?.byDate?ho(t.byDate):!1}async forceReload(e){await this.clearCache(),await this.initialize(e)}async clearCache(){i(this,D).clear(),m(i(this,ne),null),i(this,x)&&await i(this,x).clear(),console.log("[ProductsStore] Cache vidé")}setSyncStatus(e,t){const n=t?"isSyncing":"active";e.forEach(o=>{const r=i(this,D).get(o);if(r){const a={...r.data,status:n};r.update(a)}}),console.log(`[ProductsStore] Statut de synchronisation mis à jour: ${e.length} produits → ${n}`)}clearSyncStatus(){const e=[];for(const[t,n]of i(this,D))n.status==="isSyncing"&&e.push(t);e.length>0&&(this.setSyncStatus(e,!1),console.log(`[ProductsStore] Nettoyage de ${e.length} produits en statut "isSyncing"`))}reset(){var e;console.log(`[ProductsStore] Reset pour eventId: ${p(i(this,ue))}`),(e=i(this,je))==null||e.call(this),j(this,je,null),i(this,Ee)&&(i(this,Ee).call(this),j(this,Ee,null)),i(this,x)&&(i(this,x).close(),j(this,x,null)),i(this,D).clear(),i(this,ie).clear(),m(i(this,X),null),m(i(this,ue),null),m(i(this,qe),!1),m(i(this,kt),!1),m(i(this,tt),null),m(i(this,Oe),!1),m(i(this,Qe),!1),m(i(this,ne),null),j(this,nt,""),this.dateStore.reset(),m(i(this,P),{searchQuery:"",selectedStores:[],selectedWho:[],selectedProductTypes:[],selectedTemperatures:[],temperatureFilter:"all",completionStatus:"all",groupBy:"productType",sortColumn:"",sortDirection:"asc"},!0),console.log("[ProductsStore] Reset terminé")}destroy(){var e;(e=i(this,je))==null||e.call(this),j(this,je,null),i(this,x)&&(i(this,x).close(),j(this,x,null)),console.log("[ProductsStore] Ressources nettoyées")}get completionStats(){return p(i(this,Ot))}set completionStats(e){m(i(this,Ot),e)}get financialStats(){return p(i(this,Qt))}set financialStats(e){m(i(this,Qt),e)}}D=new WeakMap,ie=new WeakMap,X=new WeakMap,ue=new WeakMap,qe=new WeakMap,kt=new WeakMap,tt=new WeakMap,Oe=new WeakMap,Qe=new WeakMap,ne=new WeakMap,x=new WeakMap,je=new WeakMap,Ut=new WeakMap,P=new WeakMap,Lt=new WeakMap,xt=new WeakMap,Bt=new WeakMap,Ht=new WeakMap,zt=new WeakMap,fn=new WeakMap,Wt=new WeakMap,Gt=new WeakMap,mn=new WeakMap,T=new WeakSet,Ns=async function(e){if(!p(i(this,qe))){console.warn("[ProductsStore] Sync ignoré car store non initialisé");return}const t=JSON.stringify(e.meals);if(i(this,nt)===t)return;console.log(`[ProductsStore] ⚡️ CHANGEMENT REPAS DÉTECTÉ pour ${e.$id} (Hash: ${t.substring(0,10)}...), recalcul...`),j(this,nt,t);const o=await es(e,async a=>await Is.getRecipeByUuid(a),e.$id);o.forEach(a=>{const c=i(this,D).get(a.$id);if(c){const u={...c.data,byDate:a.byDate,totalNeededArray:a.totalNeededArray,totalNeededRaw:a.totalNeededRaw,nbRecipes:a.nbRecipes,totalAssiettes:a.totalAssiettes};Ro(u),c.update(u)}else i(this,D).set(a.$id,new it(a,this.dateStore))});const r=new Set(o.map(a=>a.$id));for(const[a,c]of i(this,D))r.has(a)||!c.data.isSynced&&!c.data.purchases?.length&&i(this,D).delete(a);this.dateStore.setAvailableDates([...e.allDates||[]]),S(this,T,ln).call(this)},nt=new WeakMap,Ee=new WeakMap,qs=async function(e){const n=await es(e,async o=>await Is.getRecipeByUuid(o),e.$id);n.forEach(o=>{i(this,D).set(o.$id,new it(o,this.dateStore))}),console.log(`[ProductsStore] ${n.length} produits calculés depuis ${e.meals.length} repas`)},js=async function(){if(i(this,x))try{const e=await i(this,x).loadProducts();e.forEach((n,o)=>{n.status==="isSyncing"&&(n.status="active"),i(this,D).set(o,new it(n,this.dateStore))});const t=await i(this,x).loadMetadata();m(i(this,ne),t.lastSync,!0),this.dateStore.setAvailableDates([...t.allDates]),console.log(`[ProductsStore] ${e.size} produits chargés du cache IDB, lastSync: ${t.lastSync}`)}catch(e){console.warn("[ProductsStore] Erreur lecture cache IDB, ignoré:",e)}},ln=async function(){if(i(this,x))try{const e=new Map;i(this,D).forEach((t,n)=>{const o=nn(t.data);o.status==="isSyncing"&&(o.status="active"),e.set(n,o)}),await i(this,x).saveProducts(e),await i(this,x).saveMetadata({lastSync:p(i(this,ne)),allDates:[...this.dateStore.dates]}),console.log("[ProductsStore] Cache IDB persisté")}catch(e){console.error("[ProductsStore] Erreur persist cache IDB:",e)}},un=async function(e){if(!(!i(this,x)||e.length===0))try{const t=e.map(n=>i(this,D).get(n)?.data).filter(n=>n!=null).map(n=>{const o=nn(n);return o.status==="isSyncing"&&(o.status="active"),i(this,x).upsertProduct(o)});t.length>0&&(await Promise.all(t),console.log(`[ProductsStore] ${t.length} produits affectés persistés`))}catch(t){console.error("[ProductsStore] Erreur persistence produits affectés:",t)}},ks=function(){m(i(this,ne),new Date().toISOString(),!0)},Cn=function(e,t){return t?sn(e,t):vo(e)},Nr=function(e){e.length&&(e.forEach(t=>S(this,T,ct).call(this,t)),console.log(`[ProductsStore] ${e.length} produits upserted`))},ct=function(e){const t=i(this,D).get(e.$id),n=S(this,T,Cn).call(this,e,t?.data);t?t.update(n):(this.dateStore.dates,i(this,D).set(e.$id,new it(n,this.dateStore)))},Us=function(e){i(this,D).delete(e)},Ls=async function(e){if(!e.products?.length)return console.warn("[ProductsStore] Purchase créé sans products:",e.$id),[];const t=e.products.map(n=>typeof n=="string"?n:n.$id).filter(Boolean);return S(this,T,Hs).call(this,t,e),t},xs=async function(e){if(e.products?.length){const t=e.products.map(n=>typeof n=="string"?n:n.$id).filter(Boolean);return S(this,T,dn).call(this,t,e),t}console.log("[ProductsStore] Purchase update sans products[], rechargement...");try{const[t]=await yr([e.$id]);if(t?.products?.length){const n=t.products.map(o=>typeof o=="string"?o:o.$id).filter(Boolean);return S(this,T,dn).call(this,n,t),n}return[]}catch(t){return console.error("[ProductsStore] Erreur rechargement purchase:",t),[]}},Bs=async function(e){const t=Array.from(i(this,D).values()).map(n=>n.data).filter(n=>n.purchases?.some(o=>o.$id===e));return t.forEach(n=>{S(this,T,ct).call(this,n)}),t.map(n=>n.$id)},Hs=function(e,t){const n=Fn(t),o=[];e.forEach(r=>{const a=i(this,D).get(r);if(a){const c=a.data,l=c.purchases||[];if(!l.some(u=>u.$id===n.$id)){const u=sn({...c,purchases:[...l,n],status:"active"},c);o.push(u)}}}),o.forEach(r=>{const a=i(this,D).get(r.$id);a&&a.update(r)})},dn=function(e,t){const n=Fn(t),o=[];e.forEach(r=>{const a=i(this,D).get(r);if(a){const c=a.data,l=c.purchases||[],u=l.findIndex(d=>d.$id===n.$id);if(u>=0){const d=[...l];d[u]=n;const h=sn({...c,purchases:d,status:"active"},c);o.push(h)}else{const d=sn({...c,purchases:[...l,t],status:"active"},c);o.push(d)}}}),o.forEach(r=>{const a=i(this,D).get(r.$id);a&&a.update(r)})},zs=function(){return{onProductCreate:e=>{if(S(this,T,ct).call(this,e),i(this,x)){const t=i(this,D).get(e.$id);t&&i(this,x).upsertProduct(nn(t.data)).catch(n=>console.error("[ProductsStore] Erreur persistence produit:",n))}},onProductUpdate:e=>{if(S(this,T,ct).call(this,e),i(this,x)){const t=i(this,D).get(e.$id);t&&i(this,x).upsertProduct(nn(t.data)).catch(n=>console.error("[ProductsStore] Erreur persistence produit:",n))}},onProductDelete:e=>{S(this,T,Us).call(this,e),i(this,x)&&i(this,x).deleteProduct(e).catch(t=>console.error("[ProductsStore] Erreur suppression produit:",t))},onPurchaseCreate:async e=>{if(e.status==="expense"){i(this,ie).set(e.$id,e);return}const t=await S(this,T,Ls).call(this,e);await S(this,T,un).call(this,t)},onPurchaseUpdate:async e=>{if(e.status==="expense"){i(this,ie).set(e.$id,e);return}i(this,ie).has(e.$id)&&i(this,ie).delete(e.$id);const t=await S(this,T,xs).call(this,e);await S(this,T,un).call(this,t)},onPurchaseDelete:async e=>{if(i(this,ie).has(e)){i(this,ie).delete(e);return}const t=await S(this,T,Bs).call(this,e);await S(this,T,un).call(this,t)},onConnect:()=>{m(i(this,Qe),!0)},onDisconnect:()=>{m(i(this,Qe),!1)},onError:e=>{console.error("[ProductsStore] Erreur realtime:",e)}}},Ws=function(e){const t=Te(),n=Be("products"),o=Be("purchases"),r=[`databases.${t}.collections.${n}.documents`,`databases.${t}.collections.${o}.documents`],a=c=>{const{events:l,payload:u}=c;if(!u)return;if(c.event==="client.connected"){e.onConnect();return}const d=l.some(R=>R.includes("products.")),h=l.some(R=>R.includes("purchases.")),y=l.some(R=>R.includes(".create")),w=l.some(R=>R.includes(".update")),E=l.some(R=>R.includes(".delete"));if(d){const R=u;R.updatedBy&&R.updatedBy!==k.userName&&(y||w?Se.info(`${R.updatedBy} a modifié le produit "${R.productName}"`,{source:"realtime-other"}):E&&Se.info(`${R.updatedBy} a supprimé un produit`,{source:"realtime-other"})),y&&e.onProductCreate?e.onProductCreate(R):w&&e.onProductUpdate?e.onProductUpdate(R):E&&e.onProductDelete&&e.onProductDelete(R.$id)}else if(h){const R=u;if(R.createdBy&&R.createdBy!==k.userName){const Q="un produit";y&&R.who!==k.userName?Se.info(`${R.who} a ajouté un achat pour ${Q}`,{source:"realtime-other"}):w&&R.who!==k.userName?Se.info(`${R.who} a modifié un achat pour ${Q}`,{source:"realtime-other"}):E&&Se.info(`${R.who} a supprimé un achat pour ${Q}`,{source:"realtime-other"})}y&&e.onPurchaseCreate?e.onPurchaseCreate(R):w&&e.onPurchaseUpdate?e.onPurchaseUpdate(R):E&&e.onPurchaseDelete&&e.onPurchaseDelete(R.$id)}};j(this,je,Vt.registerDynamic(r,a)),console.log(`[ProductsStore] ✅ Realtime configuré via RealtimeManager (${r.length} channels)`)},Gs=async function(){if(p(i(this,X)))try{const e=await gr(p(i(this,X)));e.forEach(t=>{i(this,ie).set(t.$id,t)}),console.log(`[ProductsStore] ${e.length} dépenses globales chargées`)}catch(e){console.error("[ProductsStore] Erreur chargement dépenses globales:",e)}},Ot=new WeakMap,Qt=new WeakMap;const qr=new _r,Yt=ot(),Xt="materiel";async function vi(s){try{const{tables:e}=await b();return(await e.listRows({databaseId:Yt.APPWRITE_CONFIG.databaseId,tableId:Xt,queries:s||[]})).rows}catch(e){throw console.error("[appwrite-materiel] Error listing materiels:",e),e}}async function Ri(s,e){try{const{tables:t}=await b(),n=le.unique();let o;try{o=typeof s.owner=="string"?JSON.parse(s.owner):s.owner}catch(c){throw console.error("[appwrite-materiel] Error parsing owner:",s.owner,c),new Error("Invalid owner format")}const r=[U.read(W.user(e)),U.update(W.user(e))];o.teamId?r.push(U.read(W.team(o.teamId)),U.update(W.team(o.teamId))):o.userId&&r.push(U.read(W.user(o.userId)),U.update(W.user(o.userId)));const a=await t.createRow({databaseId:Yt.APPWRITE_CONFIG.databaseId,tableId:Xt,rowId:n,data:{name:s.name,description:s.description||null,type:s.type||null,quantity:s.quantity,status:s.status||"ok",location:s.location||null,shareableWith:s.shareableWith||null,owner:s.owner},permissions:r});return console.log(`[appwrite-materiel] Materiel created: ${n}`),a}catch(t){throw console.error("[appwrite-materiel] Error creating materiel:",t),t}}async function Ai(s,e){try{const{tables:t}=await b(),n=await t.updateRow({databaseId:Yt.APPWRITE_CONFIG.databaseId,tableId:Xt,rowId:s,data:e});return console.log(`[appwrite-materiel] Materiel updated: ${s}`),n}catch(t){throw console.error(`[appwrite-materiel] Error updating materiel ${s}:`,t),t}}async function Ti(s){try{const{tables:e}=await b();await e.deleteRow({databaseId:Yt.APPWRITE_CONFIG.databaseId,tableId:Xt,rowId:s}),console.log(`[appwrite-materiel] Materiel deleted: ${s}`)}catch(e){throw console.error(`[appwrite-materiel] Error deleting materiel ${s}:`,e),e}}function Pi(){return[`databases.${Yt.APPWRITE_CONFIG.databaseId}.collections.${Xt}.documents`]}const Zt=ot(),Ft="materiel_loan";async function $i(s){try{const{tables:e}=await b();return(await e.listRows({databaseId:Zt.APPWRITE_CONFIG.databaseId,tableId:Ft,queries:s||[]})).rows}catch(e){throw console.error("[appwrite-materiel-loan] Error listing loans:",e),e}}async function Di(s,e){try{const{tables:t}=await b(),n=le.unique(),o=[U.read(W.user(e)),U.update(W.user(e)),U.read(W.team(s.ownerId)),U.update(W.team(s.ownerId))],r=await t.createRow({databaseId:Zt.APPWRITE_CONFIG.databaseId,tableId:Ft,rowId:n,data:{startDate:s.startDate,endDate:s.endDate,responsibleId:s.responsibleId,responsibleName:s.responsibleName,ownerId:s.ownerId,ownerName:s.ownerName,materiels:s.materiels.map(a=>JSON.stringify(a)),notes:s.notes||null,status:s.status||"asked",completedAt:null,returnedAt:null,returnNotes:null},permissions:o});return console.log(`[appwrite-materiel-loan] Loan created: ${n}`),r}catch(t){throw console.error("[appwrite-materiel-loan] Error creating loan:",t),t}}async function Mi(s,e){try{const{tables:t}=await b(),n={};e.startDate!==void 0&&(n.startDate=e.startDate),e.endDate!==void 0&&(n.endDate=e.endDate),e.materiels!==void 0&&(n.materiels=e.materiels.map(r=>JSON.stringify(r))),e.status!==void 0&&(n.status=e.status),e.notes!==void 0&&(n.notes=e.notes),e.returnedAt!==void 0&&(n.returnedAt=e.returnedAt),e.returnNotes!==void 0&&(n.returnNotes=e.returnNotes);const o=await t.updateRow({databaseId:Zt.APPWRITE_CONFIG.databaseId,tableId:Ft,rowId:s,data:n});return console.log(`[appwrite-materiel-loan] Loan updated: ${s}`),o}catch(t){throw console.error(`[appwrite-materiel-loan] Error updating loan ${s}:`,t),t}}async function Ci(s){try{const{tables:e}=await b();await e.deleteRow({databaseId:Zt.APPWRITE_CONFIG.databaseId,tableId:Ft,rowId:s}),console.log(`[appwrite-materiel-loan] Loan deleted: ${s}`)}catch(e){throw console.error(`[appwrite-materiel-loan] Error deleting loan ${s}:`,e),e}}function _i(){return[`databases.${Zt.APPWRITE_CONFIG.databaseId}.collections.${Ft}.documents`]}const gn="teamdocs";async function Ni(){try{const{tables:s,config:e}=await b();return(await s.listRows({databaseId:e.databaseId,tableId:gn})).rows}catch(s){throw console.error("[appwrite-teamdocs] Error listing documents:",s),s}}async function qi(s,e,t,n){try{const{tables:o,config:r}=await b(),a=[U.read(W.team(e)),U.update(W.team(e)),U.delete(W.team(e))],c=await o.createRow({databaseId:r.databaseId,tableId:gn,rowId:le.unique(),data:{...s,teamId:e,createdBy:t},permissions:a});return console.log(`[appwrite-teamdocs] Document created: ${c.$id}`),c}catch(o){throw console.error("[appwrite-teamdocs] Error creating document:",o),o}}async function jr(s,e){try{const{tables:t,config:n}=await b(),o=await t.updateRow({databaseId:n.databaseId,tableId:gn,rowId:s,data:e});return console.log(`[appwrite-teamdocs] Document updated: ${s}`),o}catch(t){throw console.error(`[appwrite-teamdocs] Error updating document ${s}:`,t),t}}async function ji(s){try{const{tables:e,config:t}=await b();await e.deleteRow({databaseId:t.databaseId,tableId:gn,rowId:s}),console.log(`[appwrite-teamdocs] Document deleted: ${s}`)}catch(e){throw console.error(`[appwrite-teamdocs] Error deleting document ${s}:`,e),e}}async function ki(s,e){try{await jr(s,{lockedBy:e}),console.log(`[appwrite-teamdocs] Lock ${s} mis à jour: ${e||"libéré"}`)}catch(t){throw console.error(`[appwrite-teamdocs] Erreur verrouillage ${s}:`,t),t}}const{APPWRITE_CONFIG:wn}=ot();async function kr(s,e){return ye(async()=>{const{functions:t}=await b(),n=await t.createExecution({functionId:wn.functions.usersTeamsManager,body:JSON.stringify({action:"remove-user-from-event",mainId:s,teamId:e}),async:!1}),o=Jt(n.responseBody,{context:"removeTeamFromEvent",fallback:null});if(!o||!o.success)throw new Error(o?.error||"Erreur lors du retrait de la team");console.log(`[appwrite-functions] Team ${e} retirée de l'événement ${s}`)},{context:"AppwriteFunctions.removeTeamFromEvent",timeout:6e4,errorMessage:"Erreur lors du retrait de la team"})}async function Ur(s){return ye(async()=>{const{functions:e}=await b(),t=await e.createExecution({functionId:wn.functions.usersTeamsManager,body:JSON.stringify({action:"checkEmails",emails:s}),async:!1}),n=Jt(t.responseBody,{context:"checkUserEmails",fallback:null});if(!n||!n.success)throw new Error(n?.error||"Erreur lors de la vérification des emails");return n.data},{context:"AppwriteFunctions.checkUserEmails",timeout:15e3,errorMessage:"Erreur lors de la vérification des emails"})}async function Lr(s,e,t){const{teamIds:n=[],emails:o=[],userIds:r=[],message:a,sendEmailToExistingMembers:c=!0}=t;return ye(async()=>{const{functions:l}=await b(),u=await l.createExecution({functionId:wn.functions.usersTeamsManager,body:JSON.stringify({action:"invite",context:{type:"event",id:s,name:e},teamIds:n,emails:o,userIds:r,message:a,sendEmailToExistingMembers:c}),async:!1}),d=Jt(u.responseBody,{context:"inviteParticipantsToEvent",fallback:null});if(!d||!d.success)throw new Error(d?.error||"Erreur lors de l'invitation");return console.log(`[appwrite-functions] ${d.processed} invitations traitées pour ${e}`),d},{context:"AppwriteFunctions.inviteParticipantsToEvent",timeout:6e4,errorMessage:"Erreur lors de l'invitation"})}async function xr(s,e){return ye(async()=>{const{functions:t}=await b(),n=await t.createExecution({functionId:wn.functions.usersTeamsManager,body:JSON.stringify({action:"remove-user-from-event",mainId:s,userId:e}),async:!1}),o=Jt(n.responseBody,{context:"removeUserFromEvent",fallback:null});if(!o||!o.success)throw new Error(o?.error||"Erreur lors du retrait de l'utilisateur");console.log(`[appwrite-functions] Utilisateur ${e} retiré de l'événement ${s}`)},{context:"AppwriteFunctions.removeUserFromEvent",timeout:1e4,errorMessage:"Erreur lors du retrait de l'utilisateur"})}const An=Object.freeze(Object.defineProperty({__proto__:null,checkUserEmails:Ur,inviteParticipantsToEvent:Lr,removeTeamFromEvent:kr,removeUserFromEvent:xr},Symbol.toStringTag,{value:"Module"}));var Br=(s=>(s.ENTREE="entree",s.PLAT="plat",s.DESSERT="dessert",s.AUTRE="autre",s))(Br||{}),Hr=(s=>(s.PUBLIC="public",s.PRIVATE="private",s.DELETED="deleted",s))(Hr||{});const zr=600*1e3,Os={usersTeamsManager:"appwrite_warmup_usersTeamsManager",enkaData:"appwrite_warmup_enkaData"};function Qs(s){const e=localStorage.getItem(Os[s]);return e?Date.now()-parseInt(e,10)>zr:!0}function Js(s){localStorage.setItem(Os[s],Date.now().toString())}async function Vs(s,e){try{const{functions:t}=await b(),n=await t.createExecution({functionId:s,body:JSON.stringify(e)});return n.responseStatusCode===200?(console.log(`[warmup] ✅ Ping réussi pour ${s}`),!0):(console.warn(`[warmup] ⚠️ Ping échoué pour ${s}: ${n.responseStatusCode}`),!1)}catch(t){return console.error(`[warmup] ❌ Erreur ping ${s}:`,t),!1}}async function Ui(){if(!Qs("usersTeamsManager")){console.log("[warmup] ⏭️ usersTeamsManager encore chaud (< 10 min)");return}console.log("[warmup] 🔥 Réveil de usersTeamsManager..."),await Vs(jn("usersTeamsManager"),{action:"ping"}),Js("usersTeamsManager")}async function Li(){if(!Qs("enkaData")){console.log("[warmup] ⏭️ enkaData encore chaud (< 10 min)");return}console.log("[warmup] 🔥 Réveil d'enkaData..."),await Vs(jn("enkaData"),{operation:"ping"}),Js("enkaData")}const Wr=ot().APPWRITE_CONFIG;async function xi(s,e,t){try{const{functions:n}=await b(),o=await n.createExecution({functionId:Wr.functions.usersTeamsManager,body:JSON.stringify({action:"exchange-invite",userId:s,eventId:e,teamId:t})}),r=JSON.parse(o.responseBody);if(!r.success)throw new Error(r.error||"L'invitation est invalide.");return{token:r.token,userId:r.userId}}catch(n){throw console.error("[invitations] Error validating invitation:",n),n}}const Gr=7,Bi={async getLock(s){const{tables:e}=await b();try{const t=await e.getRow({databaseId:Te(),tableId:Be("locks"),rowId:s});return!t.userId||new Date(t.expiresAt)<new Date?null:t}catch(t){if(t.code===404)return null;throw t}},async acquireLock(s,e,t){const{tables:n}=await b(),o=new Date(Date.now()+Gr*60*1e3).toISOString(),r={userId:e,userName:t,expiresAt:o},a=[U.read(W.any()),U.update(W.user(e))];try{return await n.updateRow({databaseId:Te(),tableId:Be("locks"),rowId:s,data:r,permissions:a}),!0}catch(c){if(c.code===404)try{return await n.createRow({databaseId:Te(),tableId:Be("locks"),rowId:s,data:r,permissions:a}),!0}catch(l){return console.error("[locksService] Erreur création verrou:",l),!1}return console.warn("[locksService] Acquisition refusée (peut-être déjà verrouillé):",c.message),!1}},async releaseLock(s,e){const{tables:t}=await b();try{await t.updateRow({databaseId:Te(),tableId:Be("locks"),rowId:s,data:{userId:"",userName:"",expiresAt:new Date(0).toISOString()},permissions:[U.read(W.any()),U.update(W.any())]}),console.log(`[locksService] Verrou libéré (réinitialisé) pour ${s}`)}catch(n){if(n.code===404){console.log(`[locksService] Verrou déjà libéré pour ${s}`);return}console.warn("[locksService] Impossible de libérer le verrou sur le serveur:",n.message)}},subscribeToLock(s,e){const t=Te(),n=Be("locks"),o=`databases.${t}.collections.${n}.documents.${s}`;return console.log("[locksService] Enregistrement du channel de lock:",o),Vt.registerDynamic([o],r=>{if(r.events?.some(c=>c.endsWith(".delete"))){e(null);return}if(!r.payload)return;const a=r.payload;!a.userId||new Date(a.expiresAt)<new Date?e(null):e(a)})}};function Or(s,e){const t=s.reduce((o,r)=>o+r.missingQuantities.length,0),n=e.invoiceTotal?1:0;return t+n}async function Qr(s,e,t){let n=null;try{const{account:c}=await b();n=(await c.get()).$id}catch(c){console.warn("[Appwrite Transaction] Impossible de récupérer l'utilisateur connecté:",c)}const o=e.purchaseStatus||"delivered";let r=e.purchaseDeliveryDate||null;o==="delivered"&&!r&&(r=new Date().toISOString());const a=s.flatMap(c=>c.missingQuantities.map(l=>({productId:c.productId,quantity:l.q,unit:l.u,status:o,notes:e.notes||"",store:e.store||"",who:e.who||void 0,price:void 0,orderDate:null,deliveryDate:r,createdBy:n})));return{mainId:t,purchasesData:a,invoiceData:e,fromUserId:n||""}}function Jr(s,e,t=98){const n=[];let o=[],r=0;const a=!!e.invoiceTotal;let c=!1;for(const l of s){const u=l.missingQuantities.length;let d=r+u>t;a&&!c&&o.length>0&&(d=r+u+1>t),d&&o.length>0?(n.push(o),o=[l],r=u,c=!1):(o.push(l),r+=u)}return o.length>0&&n.push(o),n}async function Vr(s){try{const e=ot(),{functions:t}=await b(),n={operation:"createGroupPurchaseWithSync",data:s};console.log(`[Appwrite Interactions] Exécution du lot: ${s.purchasesData.length} achats à créer`);const o=await t.createExecution(e.APPWRITE_CONFIG.functions.batchUpdate,JSON.stringify(n),!1,"/","POST");if(o.status!=="completed")throw new Error(`Exécution échouée avec statut: ${o.status}.`);const r=JSON.parse(o.responseBody);return r.success?console.log(`[Appwrite Interactions] Lot exécuté avec succès: ${r.purchasesCreated} achats créés`):console.error("[Appwrite Interactions] Lot échoué:",r.error),r}catch(e){console.error("[Appwrite Interactions] Erreur exécution lot:",e);const t=e instanceof Error?e.message:"Erreur inconnue";return{success:!1,productsCreated:0,purchasesCreated:0,expenseCreated:!1,totalOperations:0,invoiceId:s.invoiceData.invoiceId,error:t,timestamp:new Date().toISOString()}}}async function Hi(s,e,t){if(!e?.length)return{success:!1,results:[],totalProductsCreated:0,totalPurchasesCreated:0,totalExpensesCreated:0,error:"Aucun produit à traiter"};const n=Or(e,t);console.log(`[Appwrite Interactions] Achat groupé: ${e.length} produits, ${n} achats à créer`);const o=Jr(e,t,98);console.log(`[Appwrite Interactions] Découpage en ${o.length} lot(s) pour respecter la limite de 100 achats par lot`);const r=[];let a=0,c=0,l=0;for(let h=0;h<o.length;h++){const y=o[h];console.log(`[Appwrite Interactions] Exécution du lot ${h+1}/${o.length} (${y.length} produits)`);try{const w=await Qr(y,t,s),E=await Ps(()=>Vr(w),{operationName:`Lot ${h+1}/${o.length}`,maxAutoRetries:1,autoRetryDelay:2e3});if(!E)throw new Error("Opération annulée ou échouée après tentatives");if(r.push(E),E.success)a+=E.productsCreated,c+=E.purchasesCreated,l+=E.expenseCreated?1:0;else{console.error(`[Appwrite Interactions] Erreur sur le lot ${h+1}: ${E.error}`);break}}catch(w){const E=w instanceof Error?w.message:"Erreur inconnue";console.error(`[Appwrite Interactions] Erreur lors de l'exécution du lot ${h+1}:`,w),r.push({success:!1,productsCreated:0,purchasesCreated:0,expenseCreated:!1,totalOperations:0,invoiceId:t.invoiceId,error:E,timestamp:new Date().toISOString()});break}}const u=r.every(h=>h.success),d=r.some(h=>!h.success);return{success:u,results:r,totalProductsCreated:a,totalPurchasesCreated:c,totalExpensesCreated:l,error:d?"Un ou plusieurs lots ont échoué":void 0}}export{hi as $,ni as A,wi as B,Li as C,Pr as D,Ii as E,gi as F,Ei as G,bi as H,Dr as I,Hr as J,Si as K,Ui as L,ti as M,xi as N,Bi as O,Xr as P,g as Q,Br as R,Hi as S,oi as T,qn as U,Zr as V,lo as W,mr as X,di as Y,pi as Z,En as _,k as a,ai as a0,ii as a1,ri as a2,ci as a3,li as a4,ui as a5,He as a6,uo as a7,Es as a8,Fr as a9,me as aa,go as ab,vs as ac,si as ad,wo as ae,fi as af,yi as ag,mi as ah,An as ai,b,$i as c,Pi as d,Ue as e,_i as f,Te as g,Ri as h,Ti as i,Di as j,Mi as k,vi as l,Ci as m,Re as n,Ni as o,qr as p,qi as q,Vt as r,jr as s,Se as t,Ai as u,ji as v,ki as w,Xe as x,ei as y,Is as z};
