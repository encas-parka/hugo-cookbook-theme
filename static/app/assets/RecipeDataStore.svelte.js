var $=Object.defineProperty;var v=n=>{throw TypeError(n)};var F=(n,e,t)=>e in n?$(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var S=(n,e,t)=>F(n,typeof e!="symbol"?e+"":e,t),C=(n,e,t)=>e.has(n)||v("Cannot "+t);var r=(n,e,t)=>(C(n,e,"read from private field"),t?t.call(n):e.get(n)),p=(n,e,t)=>e.has(n)?v("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(n):e.set(n,t),y=(n,e,t,o)=>(C(n,e,"write to private field"),o?o.call(n,t):e.set(n,t),t),D=(n,e,t)=>(C(n,e,"access private method"),t);import{aS as j,y as O,z as G,u as Y,m as l,A as d,V as M}from"./appwrite.js";var m,J,x;class k{constructor(){p(this,m);S(this,"dbName","recipe-data-cache");S(this,"db",null);S(this,"version",1);S(this,"INGREDIENTS_STORE","ingredients");S(this,"RECIPE_INFO_STORE","recipe-info");S(this,"METADATA_STORE","metadata");S(this,"LAST_SYNC_KEY","lastSync");S(this,"DATA_JSON_HASH_KEY","dataJsonHash");S(this,"INGREDIENTS_COUNT_KEY","ingredientsCount");S(this,"RECIPE_INFO_KEY","data")}async open(){if(this.db)return;const e=()=>new Promise((i,u)=>{const g=indexedDB.open(this.dbName,this.version);g.onerror=()=>u(g.error),g.onsuccess=()=>i(g.result),g.onupgradeneeded=_=>{const f=_.target.result;f.objectStoreNames.contains(this.INGREDIENTS_STORE)||(f.createObjectStore(this.INGREDIENTS_STORE,{keyPath:"u"}),console.log("[RecipeDataIDBCache] Store 'ingredients' créé")),f.objectStoreNames.contains(this.RECIPE_INFO_STORE)||(f.createObjectStore(this.RECIPE_INFO_STORE),console.log("[RecipeDataIDBCache] Store 'recipe-info' créé")),f.objectStoreNames.contains(this.METADATA_STORE)||(f.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[RecipeDataIDBCache] Store 'metadata' créé"))}});let t=await e();const o=t.objectStoreNames.contains(this.INGREDIENTS_STORE),a=t.objectStoreNames.contains(this.RECIPE_INFO_STORE),s=t.objectStoreNames.contains(this.METADATA_STORE);(!o||!a||!s)&&(console.warn(`[RecipeDataIDBCache] Base corrompue détectée (ingredients=${o}, recipe-info=${a}, metadata=${s}), suppression et recréation...`),t.close(),await new Promise((i,u)=>{const g=indexedDB.deleteDatabase(this.dbName);g.onsuccess=()=>i(),g.onerror=()=>u(g.error),g.onblocked=()=>{console.warn("[RecipeDataIDBCache] Suppression bloquée, réessai...")}}),t=await e()),this.db=t,console.log(`[RecipeDataIDBCache] Base ouverte: ${this.dbName}`)}async loadAll(){if(!this.db)throw new Error("DB non ouverte");const[e,t]=await Promise.all([D(this,m,J).call(this),D(this,m,x).call(this)]);return{ingredients:e,recipeInfo:t}}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();s.onsuccess=()=>{const i={lastSync:null,dataJsonHash:null,ingredientsCount:0};s.result.forEach(u=>{u.key===this.LAST_SYNC_KEY?i.lastSync=u.value:u.key===this.DATA_JSON_HASH_KEY?i.dataJsonHash=u.value:u.key===this.INGREDIENTS_COUNT_KEY&&(i.ingredientsCount=u.value)}),console.log(`[RecipeDataIDBCache] Metadata: count=${i.ingredientsCount}, hash=${i.dataJsonHash?.slice(0,8)}...`),e(i)},s.onerror=()=>t(s.error)})}async saveAll(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const a=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE],"readwrite"),s=a.objectStore(this.INGREDIENTS_STORE);s.clear(),e.ingredients.forEach(u=>{s.put(u)}),a.objectStore(this.RECIPE_INFO_STORE).put(e.recipeInfo,this.RECIPE_INFO_KEY),a.oncomplete=()=>{console.log(`[RecipeDataIDBCache] ✓ ${e.ingredients.size} ingrédients + recipe-info sauvegardés`),t()},a.onerror=()=>o(a.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const a=this.db.transaction(this.METADATA_STORE,"readwrite"),s=a.objectStore(this.METADATA_STORE);s.put({key:this.LAST_SYNC_KEY,value:e.lastSync}),s.put({key:this.DATA_JSON_HASH_KEY,value:e.dataJsonHash}),s.put({key:this.INGREDIENTS_COUNT_KEY,value:e.ingredientsCount}),a.oncomplete=()=>{console.log("[RecipeDataIDBCache] ✓ Metadata sauvegardées"),t()},a.onerror=()=>o(a.error)})}async updateDataJsonHash(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.DATA_JSON_HASH_KEY,value:e});i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Hash mis à jour: ${e?.slice(0,8)||"null"}`),t()},i.onerror=()=>o(i.error)})}async upsertIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).put(e);i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient upsert: ${e.n}`),t()},i.onerror=()=>o(i.error)})}async deleteIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).delete(e);i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient supprimé: ${e}`),t()},i.onerror=()=>o(i.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const o=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE,this.METADATA_STORE],"readwrite");o.objectStore(this.INGREDIENTS_STORE).clear(),o.objectStore(this.RECIPE_INFO_STORE).clear(),o.objectStore(this.METADATA_STORE).clear(),o.oncomplete=()=>{console.log("[RecipeDataIDBCache] Cache vidé"),e()},o.onerror=()=>t(o.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[RecipeDataIDBCache] Connexion fermée"))}}m=new WeakSet,J=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.INGREDIENTS_STORE,"readonly").objectStore(this.INGREDIENTS_STORE).getAll();s.onsuccess=()=>{const i=new Map;s.result.forEach(u=>{i.set(u.u,u)}),console.log(`[RecipeDataIDBCache] ${i.size} ingrédients chargés`),e(i)},s.onerror=()=>t(s.error)})},x=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.RECIPE_INFO_STORE,"readonly").objectStore(this.RECIPE_INFO_STORE).get(this.RECIPE_INFO_KEY);s.onsuccess=()=>{const i=s.result||{materiel:[],categories:[],regimes:[]};console.log(`[RecipeDataIDBCache] recipe-info chargé: ${i.categories?.length||0} catégories`),e(i)},s.onerror=()=>t(s.error)})};async function K(){const n=new k;return await n.open(),n}function P(n){return{materiel:[...n.materiel],categories:[...n.categories],regimes:[...n.regimes]}}const z="/data/ingredients.json",q="/data/recipe-info.json";var E,h,w,T,N,I,c,b,R,B,H,A;class L{constructor(){p(this,R);p(this,E,new j);p(this,h,O(G({materiel:[],categories:[],regimes:[]})));p(this,w,O(!1));p(this,T,O(null));p(this,N,O(null));p(this,I,O(!1));p(this,c,null);p(this,b,Y(()=>Array.from(r(this,E).values()).map(e=>e.n).sort()))}get loading(){return l(r(this,w))}get error(){return l(r(this,T))}get lastSync(){return l(r(this,N))}get isInitialized(){return l(r(this,I))}get ingredients(){return Array.from(r(this,E).values()).sort((e,t)=>e.n.localeCompare(t.n,"fr"))}get count(){return r(this,E).size}get ingredientNames(){return l(r(this,b))}get materiel(){return l(r(this,h)).materiel}get categories(){return l(r(this,h)).categories}get regimes(){return l(r(this,h)).regimes}async initialize(){if(l(r(this,I))){console.log("[RecipeDataStore] Déjà initialisé");return}console.log("[RecipeDataStore] Initialisation..."),d(r(this,w),!0),d(r(this,T),null);try{y(this,c,await K());const e=await r(this,c).loadAll(),t=await r(this,c).loadMetadata();e.ingredients.size>0&&(console.log(`[RecipeDataStore] Cache: ${e.ingredients.size} ingrédients`),y(this,E,new j(e.ingredients)),d(r(this,h),e.recipeInfo,!0),d(r(this,N),t.lastSync,!0)),await D(this,R,B).call(this),d(r(this,I),!0),console.log(`[RecipeDataStore] ✓ ${r(this,E).size} ingrédients, ${l(r(this,h)).categories.length} catégories`)}catch(e){const t=e instanceof Error?e.message:"Erreur initialisation";throw d(r(this,T),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{d(r(this,w),!1)}}getIngredientByUuid(e){return r(this,E).get(e)||null}searchIngredients(e){if(!e.trim())return this.ingredients;const t=e.toLowerCase();return this.ingredients.filter(o=>o.n.toLowerCase().includes(t))}getIngredientsByType(e){return this.ingredients.filter(t=>t.t===e)}get availableTypes(){const e=new Set;return this.ingredients.forEach(t=>e.add(t.t)),Array.from(e).sort()}getIngredientsByAllergen(e){return this.ingredients.filter(t=>t.a?.includes(e))}get availableAllergens(){const e=new Set;return this.ingredients.forEach(t=>{t.a?.forEach(o=>e.add(o))}),Array.from(e).sort()}async addIngredient(e){if(!l(r(this,I)))throw new Error("Store non initialisé");try{console.log("[RecipeDataStore] Ajout ingrédient:",e.name);const{functions:t}=await M(),o=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"add_ingredient",data:{name:e.name,type:e.type,allergens:e.allergens,pF:e.pF,pS:e.pS,saisons:e.saisons}}),async:!1}),a=JSON.parse(o.responseBody);if(!a.success)throw new Error(a.error||"Erreur lors de la création de l'ingrédient");const s=a.ingredient;return r(this,E).set(s.u,s),r(this,c)&&await r(this,c).upsertIngredient(s),r(this,c)&&await r(this,c).updateDataJsonHash(null),console.log(`[RecipeDataStore] ✓ Ingrédient ajouté: ${s.n} (${s.u})`),s}catch(t){throw console.error("[RecipeDataStore] Erreur ajout ingrédient:",t),t}}async addCategory(e){if(l(r(this,h)).categories.includes(e)){console.warn(`[RecipeDataStore] Catégorie déjà existante: ${e}`);return}await D(this,R,A).call(this,{...l(r(this,h)),categories:[...l(r(this,h)).categories,e].sort()})}async addMateriel(e){if(l(r(this,h)).materiel.includes(e)){console.warn(`[RecipeDataStore] Matériel déjà existant: ${e}`);return}await D(this,R,A).call(this,{...l(r(this,h)),materiel:[...l(r(this,h)).materiel,e].sort()})}async addRegime(e){if(l(r(this,h)).regimes.includes(e)){console.warn(`[RecipeDataStore] Régime déjà existant: ${e}`);return}await D(this,R,A).call(this,{...l(r(this,h)),regimes:[...l(r(this,h)).regimes,e].sort()})}async forceReload(){console.log("[RecipeDataStore] Rechargement forcé..."),d(r(this,w),!0),d(r(this,T),null);try{r(this,c)&&await r(this,c).updateDataJsonHash(null),await D(this,R,B).call(this),console.log("[RecipeDataStore] ✓ Rechargement complété")}catch(e){const t=e instanceof Error?e.message:"Erreur rechargement";throw d(r(this,T),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{d(r(this,w),!1)}}async clearCache(){r(this,c)&&(await r(this,c).clear(),console.log("[RecipeDataStore] Cache vidé")),r(this,E).clear(),d(r(this,h),{materiel:[],categories:[],regimes:[]},!0),d(r(this,N),null),d(r(this,I),!1)}destroy(){r(this,c)&&(r(this,c).close(),y(this,c,null)),r(this,E).clear(),d(r(this,I),!1),console.log("[RecipeDataStore] Ressources nettoyées")}}E=new WeakMap,h=new WeakMap,w=new WeakMap,T=new WeakMap,N=new WeakMap,I=new WeakMap,c=new WeakMap,b=new WeakMap,R=new WeakSet,B=async function(){try{console.log("[RecipeDataStore] Fetch JSON...");const[e,t]=await Promise.all([fetch(z),fetch(q)]);if(!e.ok||!t.ok)throw new Error("Erreur HTTP lors du chargement des JSON");const[o,a]=await Promise.all([e.json(),t.json()]),s=await D(this,R,H).call(this,JSON.stringify(o)+JSON.stringify(a));if((await r(this,c).loadMetadata()).dataJsonHash===s){console.log("[RecipeDataStore] JSON inchangés, cache valide");return}console.log("[RecipeDataStore] Mise à jour depuis JSON...");const u=o.sort((_,f)=>_.n.localeCompare(f.n,"fr")),g=new Map;u.forEach(_=>{g.set(_.u,_)}),y(this,E,new j(g)),d(r(this,h),a,!0),d(r(this,N),new Date().toISOString(),!0),r(this,c)&&(await r(this,c).saveAll({ingredients:g,recipeInfo:P(l(r(this,h)))}),await r(this,c).saveMetadata({lastSync:l(r(this,N)),dataJsonHash:s,ingredientsCount:g.size})),console.log(`[RecipeDataStore] ✓ Cache mis à jour (hash: ${s.slice(0,8)}...)`)}catch(e){throw console.error("[RecipeDataStore] Erreur chargement JSON:",e),e}},H=async function(e){const o=new TextEncoder().encode(e),a=await crypto.subtle.digest("SHA-256",o);return Array.from(new Uint8Array(a)).map(i=>i.toString(16).padStart(2,"0")).join("")},A=async function(e){try{console.log("[RecipeDataStore] Mise à jour recipe-info...");const{functions:t}=await M(),o=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"update_recipe_info",data:e}),async:!1}),a=JSON.parse(o.responseBody);if(!a.success)throw new Error(a.error||"Erreur lors de la mise à jour du recipe-info");d(r(this,h),e,!0),r(this,c)&&(await r(this,c).saveAll({ingredients:new Map(r(this,E)),recipeInfo:P(e)}),await r(this,c).updateDataJsonHash(null)),console.log("[RecipeDataStore] ✓ recipe-info mis à jour")}catch(t){throw console.error("[RecipeDataStore] Erreur MAJ recipe-info:",t),t}};const V=new L;export{V as r};
