var $=Object.defineProperty;var v=a=>{throw TypeError(a)};var F=(a,e,t)=>e in a?$(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var g=(a,e,t)=>F(a,typeof e!="symbol"?e+"":e,t),C=(a,e,t)=>e.has(a)||v("Cannot "+t);var r=(a,e,t)=>(C(a,e,"read from private field"),t?t.call(a):e.get(a)),p=(a,e,t)=>e.has(a)?v("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(a):e.set(a,t),y=(a,e,t,o)=>(C(a,e,"write to private field"),o?o.call(a,t):e.set(a,t),t),D=(a,e,t)=>(C(a,e,"access private method"),t);import{aE as j,y as O,z as G,u as Y,m as h,A as d,aF as M,V as P}from"./appwrite.js";var m,J,x;class k{constructor(){p(this,m);g(this,"dbName","recipe-data-cache");g(this,"db",null);g(this,"version",1);g(this,"INGREDIENTS_STORE","ingredients");g(this,"RECIPE_INFO_STORE","recipe-info");g(this,"METADATA_STORE","metadata");g(this,"LAST_SYNC_KEY","lastSync");g(this,"DATA_JSON_HASH_KEY","dataJsonHash");g(this,"INGREDIENTS_COUNT_KEY","ingredientsCount");g(this,"RECIPE_INFO_KEY","data")}async open(){if(this.db)return;const e=()=>new Promise((i,u)=>{const E=indexedDB.open(this.dbName,this.version);E.onerror=()=>u(E.error),E.onsuccess=()=>i(E.result),E.onupgradeneeded=_=>{const f=_.target.result;f.objectStoreNames.contains(this.INGREDIENTS_STORE)||(f.createObjectStore(this.INGREDIENTS_STORE,{keyPath:"u"}),console.log("[RecipeDataIDBCache] Store 'ingredients' créé")),f.objectStoreNames.contains(this.RECIPE_INFO_STORE)||(f.createObjectStore(this.RECIPE_INFO_STORE),console.log("[RecipeDataIDBCache] Store 'recipe-info' créé")),f.objectStoreNames.contains(this.METADATA_STORE)||(f.createObjectStore(this.METADATA_STORE,{keyPath:"key"}),console.log("[RecipeDataIDBCache] Store 'metadata' créé"))}});let t=await e();const o=t.objectStoreNames.contains(this.INGREDIENTS_STORE),n=t.objectStoreNames.contains(this.RECIPE_INFO_STORE),s=t.objectStoreNames.contains(this.METADATA_STORE);(!o||!n||!s)&&(console.warn(`[RecipeDataIDBCache] Base corrompue détectée (ingredients=${o}, recipe-info=${n}, metadata=${s}), suppression et recréation...`),t.close(),await new Promise((i,u)=>{const E=indexedDB.deleteDatabase(this.dbName);E.onsuccess=()=>i(),E.onerror=()=>u(E.error),E.onblocked=()=>{console.warn("[RecipeDataIDBCache] Suppression bloquée, réessai...")}}),t=await e()),this.db=t,console.log(`[RecipeDataIDBCache] Base ouverte: ${this.dbName}`)}async loadAll(){if(!this.db)throw new Error("DB non ouverte");const[e,t]=await Promise.all([D(this,m,J).call(this),D(this,m,x).call(this)]);return{ingredients:e,recipeInfo:t}}async loadMetadata(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.METADATA_STORE,"readonly").objectStore(this.METADATA_STORE).getAll();s.onsuccess=()=>{const i={lastSync:null,dataJsonHash:null,ingredientsCount:0};s.result.forEach(u=>{u.key===this.LAST_SYNC_KEY?i.lastSync=u.value:u.key===this.DATA_JSON_HASH_KEY?i.dataJsonHash=u.value:u.key===this.INGREDIENTS_COUNT_KEY&&(i.ingredientsCount=u.value)}),console.log(`[RecipeDataIDBCache] Metadata: count=${i.ingredientsCount}, hash=${i.dataJsonHash?.slice(0,8)}...`),e(i)},s.onerror=()=>t(s.error)})}async saveAll(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const n=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE],"readwrite"),s=n.objectStore(this.INGREDIENTS_STORE);s.clear(),e.ingredients.forEach(u=>{s.put(u)}),n.objectStore(this.RECIPE_INFO_STORE).put(e.recipeInfo,this.RECIPE_INFO_KEY),n.oncomplete=()=>{console.log(`[RecipeDataIDBCache] ✓ ${e.ingredients.size} ingrédients + recipe-info sauvegardés`),t()},n.onerror=()=>o(n.error)})}async saveMetadata(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const n=this.db.transaction(this.METADATA_STORE,"readwrite"),s=n.objectStore(this.METADATA_STORE);s.put({key:this.LAST_SYNC_KEY,value:e.lastSync}),s.put({key:this.DATA_JSON_HASH_KEY,value:e.dataJsonHash}),s.put({key:this.INGREDIENTS_COUNT_KEY,value:e.ingredientsCount}),n.oncomplete=()=>{console.log("[RecipeDataIDBCache] ✓ Metadata sauvegardées"),t()},n.onerror=()=>o(n.error)})}async updateDataJsonHash(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.METADATA_STORE,"readwrite").objectStore(this.METADATA_STORE).put({key:this.DATA_JSON_HASH_KEY,value:e});i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Hash mis à jour: ${e?.slice(0,8)||"null"}`),t()},i.onerror=()=>o(i.error)})}async upsertIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).put(e);i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient upsert: ${e.n}`),t()},i.onerror=()=>o(i.error)})}async deleteIngredient(e){if(!this.db)throw new Error("DB non ouverte");return new Promise((t,o)=>{const i=this.db.transaction(this.INGREDIENTS_STORE,"readwrite").objectStore(this.INGREDIENTS_STORE).delete(e);i.onsuccess=()=>{console.log(`[RecipeDataIDBCache] Ingrédient supprimé: ${e}`),t()},i.onerror=()=>o(i.error)})}async clear(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const o=this.db.transaction([this.INGREDIENTS_STORE,this.RECIPE_INFO_STORE,this.METADATA_STORE],"readwrite");o.objectStore(this.INGREDIENTS_STORE).clear(),o.objectStore(this.RECIPE_INFO_STORE).clear(),o.objectStore(this.METADATA_STORE).clear(),o.oncomplete=()=>{console.log("[RecipeDataIDBCache] Cache vidé"),e()},o.onerror=()=>t(o.error)})}close(){this.db&&(this.db.close(),this.db=null,console.log("[RecipeDataIDBCache] Connexion fermée"))}}m=new WeakSet,J=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.INGREDIENTS_STORE,"readonly").objectStore(this.INGREDIENTS_STORE).getAll();s.onsuccess=()=>{const i=new Map;s.result.forEach(u=>{i.set(u.u,u)}),console.log(`[RecipeDataIDBCache] ${i.size} ingrédients chargés`),e(i)},s.onerror=()=>t(s.error)})},x=async function(){if(!this.db)throw new Error("DB non ouverte");return new Promise((e,t)=>{const s=this.db.transaction(this.RECIPE_INFO_STORE,"readonly").objectStore(this.RECIPE_INFO_STORE).get(this.RECIPE_INFO_KEY);s.onsuccess=()=>{const i=s.result||{materiel:[],categories:[],regimes:[]};console.log(`[RecipeDataIDBCache] recipe-info chargé: ${i.categories?.length||0} catégories`),e(i)},s.onerror=()=>t(s.error)})};async function K(){const a=new k;return await a.open(),a}const z="/data/ingredients.json",q="/data/recipe-info.json";var S,l,w,T,N,I,c,b,R,B,H,A;class L{constructor(){p(this,R);p(this,S,new j);p(this,l,O(G({materiel:[],categories:[],regimes:[]})));p(this,w,O(!1));p(this,T,O(null));p(this,N,O(null));p(this,I,O(!1));p(this,c,null);p(this,b,Y(()=>Array.from(r(this,S).values()).map(e=>e.n).sort()))}get loading(){return h(r(this,w))}get error(){return h(r(this,T))}get lastSync(){return h(r(this,N))}get isInitialized(){return h(r(this,I))}get ingredients(){return Array.from(r(this,S).values()).sort((e,t)=>e.n.localeCompare(t.n,"fr"))}get count(){return r(this,S).size}get ingredientNames(){return h(r(this,b))}get materiel(){return h(r(this,l)).materiel}get categories(){return h(r(this,l)).categories}get regimes(){return h(r(this,l)).regimes}async initialize(){if(h(r(this,I))){console.log("[RecipeDataStore] Déjà initialisé");return}console.log("[RecipeDataStore] Initialisation..."),d(r(this,w),!0),d(r(this,T),null);try{y(this,c,await K());const e=await r(this,c).loadAll(),t=await r(this,c).loadMetadata();e.ingredients.size>0&&(console.log(`[RecipeDataStore] Cache: ${e.ingredients.size} ingrédients`),y(this,S,new j(e.ingredients)),d(r(this,l),e.recipeInfo,!0),d(r(this,N),t.lastSync,!0)),await D(this,R,B).call(this),d(r(this,I),!0),console.log(`[RecipeDataStore] ✓ ${r(this,S).size} ingrédients, ${h(r(this,l)).categories.length} catégories`)}catch(e){const t=e instanceof Error?e.message:"Erreur initialisation";throw d(r(this,T),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{d(r(this,w),!1)}}getIngredientByUuid(e){return r(this,S).get(e)||null}searchIngredients(e){if(!e.trim())return this.ingredients;const t=e.toLowerCase();return this.ingredients.filter(o=>o.n.toLowerCase().includes(t))}getIngredientsByType(e){return this.ingredients.filter(t=>t.t===e)}get availableTypes(){const e=new Set;return this.ingredients.forEach(t=>e.add(t.t)),Array.from(e).sort()}getIngredientsByAllergen(e){return this.ingredients.filter(t=>t.a?.includes(e))}get availableAllergens(){const e=new Set;return this.ingredients.forEach(t=>{t.a?.forEach(o=>e.add(o))}),Array.from(e).sort()}async addIngredient(e){if(!h(r(this,I)))throw new Error("Store non initialisé");try{console.log("[RecipeDataStore] Ajout ingrédient:",e.name);const{functions:t}=await P(),o=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"add_ingredient",data:{name:e.name,type:e.type,allergens:e.allergens,pF:e.pF,pS:e.pS,saisons:e.saisons}}),async:!1}),n=JSON.parse(o.responseBody);if(!n.success)throw new Error(n.error||"Erreur lors de la création de l'ingrédient");const s=n.ingredient;return r(this,S).set(s.u,s),r(this,c)&&await r(this,c).upsertIngredient(s),r(this,c)&&await r(this,c).updateDataJsonHash(null),console.log(`[RecipeDataStore] ✓ Ingrédient ajouté: ${s.n} (${s.u})`),s}catch(t){throw console.error("[RecipeDataStore] Erreur ajout ingrédient:",t),t}}async addCategory(e){if(h(r(this,l)).categories.includes(e)){console.warn(`[RecipeDataStore] Catégorie déjà existante: ${e}`);return}await D(this,R,A).call(this,{...h(r(this,l)),categories:[...h(r(this,l)).categories,e].sort()})}async addMateriel(e){if(h(r(this,l)).materiel.includes(e)){console.warn(`[RecipeDataStore] Matériel déjà existant: ${e}`);return}await D(this,R,A).call(this,{...h(r(this,l)),materiel:[...h(r(this,l)).materiel,e].sort()})}async addRegime(e){if(h(r(this,l)).regimes.includes(e)){console.warn(`[RecipeDataStore] Régime déjà existant: ${e}`);return}await D(this,R,A).call(this,{...h(r(this,l)),regimes:[...h(r(this,l)).regimes,e].sort()})}async forceReload(){console.log("[RecipeDataStore] Rechargement forcé..."),d(r(this,w),!0),d(r(this,T),null);try{r(this,c)&&await r(this,c).updateDataJsonHash(null),await D(this,R,B).call(this),console.log("[RecipeDataStore] ✓ Rechargement complété")}catch(e){const t=e instanceof Error?e.message:"Erreur rechargement";throw d(r(this,T),t,!0),console.error("[RecipeDataStore]",t,e),e}finally{d(r(this,w),!1)}}async clearCache(){r(this,c)&&(await r(this,c).clear(),console.log("[RecipeDataStore] Cache vidé")),r(this,S).clear(),d(r(this,l),{materiel:[],categories:[],regimes:[]},!0),d(r(this,N),null),d(r(this,I),!1)}destroy(){r(this,c)&&(r(this,c).close(),y(this,c,null)),r(this,S).clear(),d(r(this,I),!1),console.log("[RecipeDataStore] Ressources nettoyées")}}S=new WeakMap,l=new WeakMap,w=new WeakMap,T=new WeakMap,N=new WeakMap,I=new WeakMap,c=new WeakMap,b=new WeakMap,R=new WeakSet,B=async function(){try{console.log("[RecipeDataStore] Fetch JSON...");const[e,t]=await Promise.all([fetch(z),fetch(q)]);if(!e.ok||!t.ok)throw new Error("Erreur HTTP lors du chargement des JSON");const[o,n]=await Promise.all([e.json(),t.json()]),s=await D(this,R,H).call(this,JSON.stringify(o)+JSON.stringify(n));if((await r(this,c).loadMetadata()).dataJsonHash===s){console.log("[RecipeDataStore] JSON inchangés, cache valide");return}console.log("[RecipeDataStore] Mise à jour depuis JSON...");const u=o.sort((_,f)=>_.n.localeCompare(f.n,"fr")),E=new Map;u.forEach(_=>{E.set(_.u,_)}),y(this,S,new j(E)),d(r(this,l),n,!0),d(r(this,N),new Date().toISOString(),!0),r(this,c)&&(await r(this,c).saveAll({ingredients:E,recipeInfo:M(h(r(this,l)))}),await r(this,c).saveMetadata({lastSync:h(r(this,N)),dataJsonHash:s,ingredientsCount:E.size})),console.log(`[RecipeDataStore] ✓ Cache mis à jour (hash: ${s.slice(0,8)}...)`)}catch(e){throw console.error("[RecipeDataStore] Erreur chargement JSON:",e),e}},H=async function(e){const o=new TextEncoder().encode(e),n=await crypto.subtle.digest("SHA-256",o);return Array.from(new Uint8Array(n)).map(i=>i.toString(16).padStart(2,"0")).join("")},A=async function(e){try{console.log("[RecipeDataStore] Mise à jour recipe-info...");const{functions:t}=await P(),o=await t.createExecution({functionId:"68f00487000c624533a3",body:JSON.stringify({action:"update_recipe_info",data:e}),async:!1}),n=JSON.parse(o.responseBody);if(!n.success)throw new Error(n.error||"Erreur lors de la mise à jour du recipe-info");d(r(this,l),e,!0),r(this,c)&&(await r(this,c).saveAll({ingredients:new Map(r(this,S)),recipeInfo:M(e)}),await r(this,c).updateDataJsonHash(null)),console.log("[RecipeDataStore] ✓ recipe-info mis à jour")}catch(t){throw console.error("[RecipeDataStore] Erreur MAJ recipe-info:",t),t}};const V=new L;export{V as r};
