{{- /* event-data-processor.html Partial centralisé pour traiter toutes les données d'un événement. Il parcourt les repas et les recettes UNE SEULE FOIS, et construit toutes les structures de données nécessaires pour les différents formats de sortie JSON. Input: - Contexte de la page (.) Output: (dict) - ingredient_totals: Map pour single.ingredients_aw.json - ingredient_by_date: Map pour single.ingredients_aw.json - ingByTypeList: Slice pour single.ingredientsjson.json - datesRepas, datesTimeRepas, startDate, endDate - types: Slice des types d'ingrédients - recettesLength, nbDate, uniqueIngCount - missingRecipes */}}
{{- $pageContext := . -}}
{{- /* Index globaux */}}
{{- $recettesIndex := partialCached "functions/recettes-index.html"
  "recettes-index-global"
-}}
{{- $byUUIDRecette := cond (and $recettesIndex
  (isset $recettesIndex "byUUIDRecette")) $recettesIndex.byUUIDRecette (dict)
-}}
{{- $ingredientsIndex := partialCached "functions/ingredients-index.html"
  "ingredients-index"
-}}
{{- $byUUIDIng := cond (and $ingredientsIndex (isset
  $ingredientsIndex "byUUID")) $ingredientsIndex.byUUID (dict)
-}}
{{- /* Initialisation de TOUTES les structures de données */}}
{{- /* Pour ingredients_aw.json */}}
{{- $ingredient_totals := dict -}}
{{- $ingredient_by_date:= dict -}}
{{- $totalAssiettesByIngredient := dict -}}
{{- $totalRecipesByIngredient := dict -}}
{{- /* Pour ingredientsjson.json */}}
{{- $IngTypeListGrouped := dict -}}
{{- $typesSet := dict -}}
{{- $uniqueIngSet := dict -}}
{{- $datesRepas := slice -}}
{{- $datesTimeRepas := slice -}}
{{- $recettesLength := 0 -}}
{{- $nbDate := 0 -}}
{{- $missingRecipes := slice -}}
{{- /* Pour ingredients_aw.json */}}
{{- $allDates := slice -}}
{{- $conversionCache := dict -}}


{{- /* PHASE 1.5: Identifier les ingrédients qui nécessitent un traitement byDate complet */}}

{{- /* Boucle de traitement principal */}}
{{- range $pageContext.Param "repas" -}}
  {{- $dateService := .date_service -}}
  {{- $dateTimeService := .date_service -}}
  {{- $nbDate = add $nbDate 1 -}}
  {{- $horaire := .horaire -}}
  {{- $repasBaseAssiettes := (int .assiettes) -}}
  {{- /* Normalisation du datetime */}}
  {{- if not (findRE "T" $dateService) }}
    {{ $dateTimeService = printf "%sT12:00:00" $dateService }}
  {{ end -}}
  {{- if eq
    $horaire "matin"
  }}
    {{ $dateTimeService = $dateTimeService | replaceRE
      "T\\d{2}:\\d{2}:\\d{2}" "T08:00:00"
    }}
  {{- else if eq $horaire "midi" }}
    {{ $dateTimeService = $dateTimeService | replaceRE "T\\d{2}:\\d{2}:\\d{2}"
      "T12:00:00"
    }}
  {{- else if eq $horaire "soir" }}
    {{ $dateTimeService =
      $dateTimeService | replaceRE "T\\d{2}:\\d{2}:\\d{2}" "T20:00:00"
    }}
  {{ end -}}
  {{- $datesRepas = $datesRepas | append $dateService -}}
  {{- $datesTimeRepas =
    $datesTimeRepas | append $dateTimeService
  -}}
  {{- $allDates = $allDates | append
    $dateTimeService
  -}}
  {{- range .recettes_du_repas -}}
    {{- $recettesLength = add
      $recettesLength 1
    -}}
    {{- $assiettesPourCalcul := $repasBaseAssiettes -}}
    {{- $typePlat := .type_plat -}}
    {{- if .altAssiettes }}
      {{ $assiettesPourCalcul =
        (int .altAssiettes)
      }}
    {{ end -}}
    {{- $uuid := partialCached
      "functions/extract-uuid-from-slug.html" .recette .recette
    -}}
    {{- $recetteMeta
      := cond (and $uuid (ne $uuid "")) (index $byUUIDRecette $uuid) nil
    -}}
    {{- if
      not $recetteMeta
    -}}
      {{- $missingInfo := dict "recetteSlug" .recette
        "dateService" $dateService "horaire" $horaire "reason" "Recette non trouvée"
      -}}
      {{- $missingRecipes = $missingRecipes | append $missingInfo -}}
    {{- else -}}
      {{- $recetteName := $recetteMeta.title -}}
      {{- $assiettesRecettes :=
        $recetteMeta.plate
      -}}
      {{- $ingredients := $recetteMeta.ingredients -}}
      {{- $recetteID := $recetteMeta.File.UniqueID -}}
      {{- $builderContext := (dict
        "items" $ingredients "byUUID" $byUUIDIng "mode" "evenement" "assiettes"
        $assiettesPourCalcul "assiettesRecettes" $assiettesRecettes "splitLegumes" true
        )
      -}}
      {{- $groupedForRecette := (partial "functions/ingredients-group-builder"
        $builderContext).ingredients
      -}}
      {{- if and $groupedForRecette (reflect.IsMap $groupedForRecette) -}}
        {{- range $type, $list := $groupedForRecette -}}
          {{- if and $type (reflect.IsSlice $list) -}}
            {{- $typesSet = merge $typesSet (dict $type true) -}}

            {{- /* Agrégation pour ingredientsjson.json */}}
            {{- $currentList := index $IngTypeListGrouped $type | default (slice) -}}
            {{- $enrichedList := slice -}}

            {{- /* ✅ OPTIMISATION : Créer les métadonnées communes UNE SEULE FOIS */}}
            {{- $commonMetadata := dict
              "recette" $recetteName
              "dateService" $dateService
              "dateTimeService" $dateTimeService
              "horaire" $horaire
              "typePlat" $typePlat
              "assiettesRecettes" $assiettesRecettes
              "assiettes" $assiettesPourCalcul
            -}}

            {{- range $item := $list -}}
              {{- if and $item (reflect.IsMap $item) -}}
                {{- if .uuid }}
                  {{- $uniqueIngSet = merge $uniqueIngSet (dict .uuid true) -}}
                {{- end -}}

                {{- $enrichedItem := merge $item $commonMetadata -}}
                {{- $enrichedList = $enrichedList | append $enrichedItem -}}
              {{- end -}}
            {{- end -}}

            {{- $IngTypeListGrouped = merge $IngTypeListGrouped (dict $type ($currentList | append $enrichedList)) -}}

            {{- /* Agrégation pour ingredients_aw.json */}}
            {{- range $item := $list -}}
              {{- if and $item (reflect.IsMap $item) -}}
                {{- $name := $item.ingredient | default "" -}}
                {{- $uuid_ing := $item.uuid | default "" -}}
                {{- if ne $name "" -}}

                  {{- /* Initialisation de la structure si nécessaire */}}
                  {{- if not (index $ingredient_totals $name) -}}
                    {{- $ingMeta := index $byUUIDIng $uuid_ing -}}
                    {{- $pFrais := cond $ingMeta $ingMeta.pFrais false -}}
                    {{- $pSurgel := cond $ingMeta $ingMeta.pSurgel false -}}
                    {{- $ingredient_totals = merge $ingredient_totals
                      (dict $name (dict
                        "uuid" $uuid_ing
                        "name" $name
                        "type" $item.iType
                        "pFrais" $pFrais
                        "pSurgel" $pSurgel
                        "category_weight" 0.0
                        "category_volume" 0.0
                        "category_other" (dict)
                        "consolidated_weight" 0.0
                        "consolidated_volume" 0.0
                        "consolidated_other" (dict)
                        "has_conversion" false
                        "conversion_rules" (slice)
                      ))
                    -}}
                    {{- $ingredient_by_date = merge $ingredient_by_date (dict $name (dict)) -}}
                    {{- $totalAssiettesByIngredient = merge $totalAssiettesByIngredient (dict $name 0) -}}
                    {{- $totalRecipesByIngredient = merge $totalRecipesByIngredient (dict $name 0) -}}
                  {{- end -}}

                  {{- $current := index $ingredient_totals $name -}}
                  {{- $quantite := $item.quantite | default 0.0 -}}
                  {{- $unit := $item.unit | default "" -}}
                  {{- $quantiteEq := $item.quantiteEq | default $quantite -}}
                  {{- $unitEq := $item.unitEq | default $unit -}}
                  {{- $hasEquivalence := $item.hasConversion | default false -}}
                  {{- $conversionRule := $item.conversionRule | default "" -}}

                  {{- /* Traitement spécial pour les ingrédients sans quantité */}}
                  {{- if or (eq $quantite 0.0) (eq $quantite nil) (eq $unit "") -}}
                    {{- $quantite = 1 -}}
                    {{- $unit = "recette·s" -}}
                    {{- $quantiteEq = 1 -}}
                    {{- $unitEq = "recette·s" -}}
                  {{- end -}}

                  {{- /* Initialiser la structure pour cet ingrédient si nécessaire */}}
                  {{- $ingDates := index $ingredient_by_date $name -}}
                  {{- if not $ingDates -}}
                    {{- $ingredient_by_date = merge $ingredient_by_date (dict $name (dict)) -}}
                    {{- $ingDates = dict -}}
                  {{- end -}}

                  {{- /* Initialiser la structure pour cette date si nécessaire */}}
                  {{- $dateData := index $ingDates $dateTimeService -}}
                  {{- if not $dateData -}}
                    {{- $dateData = dict
                      "totalConsolidatedWeight" 0.0
                      "totalConsolidatedVolume" 0.0
                      "totalConsolidatedOther" (dict)
                      "recipes" (slice)
                      "totalAssiettes" 0
                      "recipeCount" 0
                      "conversionRules" (slice)
                    -}}
                  {{- end -}}

                  {{- /* Appeler le converter pour obtenir qEq et uEq */}}

                  {{- /* ✅ OPTIMISATION : Cache de conversion */}}
                  {{- $cacheKey := printf "%s|%s" $unit $name -}}
                  {{- $cachedConversion := index $conversionCache $cacheKey -}}
                  {{- if not $cachedConversion -}}
                    {{- $cachedConversion = partial "functions/quantite-converter.html"
                      (dict "quantite" 1 "unit" $unit "ingredient" $name)
                    -}}
                    {{- $conversionCache = merge $conversionCache (dict $cacheKey $cachedConversion) -}}
                  {{- end -}}

                  {{- /* Calculer la quantité réelle en appliquant le facteur de conversion */}}
                  {{- $conversionResult := dict
                    "quantiteEq" (mul $quantite (float $cachedConversion.quantiteEq))
                    "unitEq" $cachedConversion.unitEq
                    "hasConversion" $cachedConversion.hasConversion
                    "conversionRule" $cachedConversion.conversionRule
                  -}}

                  {{- $recipeEntry := dict
                    "r" $recetteName
                    "q" $quantite
                    "u" $unit
                    "qEq" $conversionResult.quantiteEq
                    "uEq" $conversionResult.unitEq
                    "a" $assiettesPourCalcul
                  -}}

                  {{- /* ✅ OPTIMISATION : Pré-calculer les valeurs avant les merge */}}
                  {{- $unitEqLower := $conversionResult.unitEq | lower -}}
                  {{- $qtyEq := float $conversionResult.quantiteEq -}}

                  {{- /* Variables pour accumulation */}}
                  {{- $newTotalConsolidatedWeight := $dateData.totalConsolidatedWeight -}}
                  {{- $newTotalConsolidatedVolume := $dateData.totalConsolidatedVolume -}}
                  {{- $newTotalConsolidatedOther := $dateData.totalConsolidatedOther -}}
                  {{- $newConversionRules := $dateData.conversionRules -}}

                  {{- /* Accumuler dans totalConsolidated */}}
                  {{- if or (eq $unitEqLower "gr.") (eq $unitEqLower "g") -}}
                    {{- $newTotalConsolidatedWeight = add $newTotalConsolidatedWeight $qtyEq -}}
                  {{- else if eq $unitEqLower "ml" -}}
                    {{- $newTotalConsolidatedVolume = add $newTotalConsolidatedVolume $qtyEq -}}
                  {{- else -}}
                    {{- $currentQty := index $newTotalConsolidatedOther $conversionResult.unitEq | default 0.0 -}}
                    {{- $newTotalConsolidatedOther = merge $newTotalConsolidatedOther
                      (dict $conversionResult.unitEq (add $currentQty $qtyEq))
                    -}}
                  {{- end -}}

                  {{- /* Garder trace des règles de conversion */}}
                  {{- if and $conversionResult.hasConversion (ne $conversionResult.conversionRule "") -}}
                    {{- if not (in $newConversionRules $conversionResult.conversionRule) -}}
                      {{- $newConversionRules = $newConversionRules | append $conversionResult.conversionRule -}}
                    {{- end -}}
                  {{- end -}}

                  {{- /* ✅ OPTIMISATION : UN SEUL merge pour mettre à jour $dateData */}}
                  {{- $dateData = merge $dateData (dict
                    "totalConsolidatedWeight" $newTotalConsolidatedWeight
                    "totalConsolidatedVolume" $newTotalConsolidatedVolume
                    "totalConsolidatedOther" $newTotalConsolidatedOther
                    "recipes" ($dateData.recipes | append $recipeEntry)
                    "totalAssiettes" (add $dateData.totalAssiettes $assiettesPourCalcul)
                    "recipeCount" (add $dateData.recipeCount 1)
                    "conversionRules" $newConversionRules
                  ) -}}

                  {{- /* Sauvegarder la dateData mise à jour */}}
                  {{- $ingDates = merge $ingDates (dict $dateTimeService $dateData) -}}
                  {{- $ingredient_by_date = merge $ingredient_by_date (dict $name $ingDates) -}}

                  {{- /* Mise à jour des totaux par ingrédient */}}
                  {{- $totalAssiettesByIngredient = merge $totalAssiettesByIngredient
                    (dict $name (add (index $totalAssiettesByIngredient $name) $assiettesPourCalcul))
                  -}}
                  {{- $totalRecipesByIngredient = merge $totalRecipesByIngredient
                    (dict $name (add (index $totalRecipesByIngredient $name) 1))
                  -}}

                  {{- /* ✅ OPTIMISATION : Pré-calculer les conversions d'unités brutes */}}
                  {{- $unitLower := $unit | lower -}}
                  {{- $isWeightUnit := or (eq $unitLower "kg") (eq $unitLower "gr.") (eq $unitLower "g") -}}
                  {{- $isVolumeUnit := or (eq $unitLower "l.") (eq $unitLower "ml") -}}

                  {{- /* Variables pour accumulation des totaux */}}
                  {{- $newCategoryWeight := $current.category_weight -}}
                  {{- $newCategoryVolume := $current.category_volume -}}
                  {{- $newCategoryOther := $current.category_other -}}
                  {{- $newConsolidatedWeight := $current.consolidated_weight -}}
                  {{- $newConsolidatedVolume := $current.consolidated_volume -}}
                  {{- $newConsolidatedOther := $current.consolidated_other -}}
                  {{- $newConversionRulesGlobal := $current.conversion_rules -}}
                  {{- $hasEquivalenceNew := $current.has_equivalence -}}

                  {{- /* Calcul des valeurs brutes (category) */}}
                  {{- if $isWeightUnit -}}
                    {{- $weightVal := cond (eq $unitLower "kg") (mul $quantite 1000) $quantite -}}
                    {{- $newCategoryWeight = add $newCategoryWeight $weightVal -}}
                  {{- else if $isVolumeUnit -}}
                    {{- $volumeVal := cond (eq $unitLower "l.") (mul $quantite 1000) $quantite -}}
                    {{- $newCategoryVolume = add $newCategoryVolume $volumeVal -}}
                  {{- else -}}
                    {{- $newCategoryOther = merge $newCategoryOther
                      (dict $unit (add (index $newCategoryOther $unit | default 0.0) $quantite))
                    -}}
                  {{- end -}}

                  {{- /* Consolidation complète (convertie) */}}
                  {{- if eq $unitEq "gr." -}}
                    {{- $newConsolidatedWeight = add $newConsolidatedWeight $quantiteEq -}}
                  {{- else if eq $unitEq "ml" -}}
                    {{- $newConsolidatedVolume = add $newConsolidatedVolume $quantiteEq -}}
                  {{- else -}}
                    {{- $newConsolidatedOther = merge $newConsolidatedOther
                      (dict $unitEq (add (index $newConsolidatedOther $unitEq | default 0.0) $quantiteEq))
                    -}}
                  {{- end -}}

                  {{- /* Mise à jour des flags et règles de conversion */}}
                  {{- if $hasEquivalence -}}
                    {{- $hasEquivalenceNew = true -}}
                    {{- if and (ne $conversionRule "") (not (in $newConversionRulesGlobal $conversionRule)) -}}
                      {{- $newConversionRulesGlobal = $newConversionRulesGlobal | append $conversionRule -}}
                    {{- end -}}
                  {{- end -}}

                  {{- /* ✅ OPTIMISATION : UN SEUL merge pour mettre à jour $current */}}
                  {{- $current = merge $current (dict
                    "category_weight" $newCategoryWeight
                    "category_volume" $newCategoryVolume
                    "category_other" $newCategoryOther
                    "consolidated_weight" $newConsolidatedWeight
                    "consolidated_volume" $newConsolidatedVolume
                    "consolidated_other" $newConsolidatedOther
                    "has_equivalence" $hasEquivalenceNew
                    "conversion_rules" $newConversionRulesGlobal
                  ) -}}

                  {{- $ingredient_totals = merge $ingredient_totals (dict $name $current) -}}
                {{- end -}}
              {{- end -}}
            {{- end -}}
          {{- end -}}
        {{- end -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
{{- end -}}
{{- /* --- Finalisation des
  données (tris, etc.) ---
*/}}
{{- $datesTimeRepas = sort $datesTimeRepas | uniq -}}
{{- $datesRepas = sort $datesRepas | uniq -}}
{{- $allDates = sort $allDates
  | uniq
-}}
{{- $types := slice -}}
{{- range $key, $value := $typesSet -}}
  {{- $types = $types | append $key -}}
{{- end -}}
{{- $types = sort $types "value"
  "desc"
-}}
{{- $ingByTypeList := slice -}}
{{- range $t := $types -}}
  {{- $items
    := sort (index $IngTypeListGrouped $t | default (slice)) "ingredient" "asc"
  -}}
  {{- $ingByTypeList = $ingByTypeList | append (dict "type" $t "items" $items) -}}
{{- end -}}
{{- /* --- Retourner le dictionnaire complet --- */}}
{{- return
  (dict "ingredient_totals" $ingredient_totals "ingredient_by_date"
  $ingredient_by_date "totalAssiettesByIngredient" $totalAssiettesByIngredient
  "totalRecipesByIngredient" $totalRecipesByIngredient  "ingByTypeList" $ingByTypeList "datesRepas" $datesRepas
  "datesTimeRepas" $datesTimeRepas "allDates" $allDates "startDate" (cond (gt (len
  $datesRepas) 0) (index $datesRepas 0) "") "endDate" (cond (gt (len $datesRepas)
  0) (index $datesRepas (sub (len $datesRepas) 1)) "") "types" $types
  "recettesLength" $recettesLength "nbDate" $nbDate "uniqueIngCount" (len
  $uniqueIngSet) "missingRecipes" $missingRecipes )
-}}
